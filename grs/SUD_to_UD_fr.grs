%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package FR_init {
  rule adv_det{
    pattern{A[cat=ADV,nom]; A -[det]-> D; D[cat=DET,lemma=le,Gender=Masc,Number=Sing]}
    without{P[cat=ADP,lemma=de]; A -[comp:obl]-> P}
    commands{del_feat A.nom}
  }

% All adjectives or verbs that are attributive of nouns are considered as non nominals.
  rule attr_det{
    pattern{
      N0[cat=NOUN|PRON]; N[cat <> INDET]; N0 -[dep_SUD]-> N;
      N[cat=ADJ|VERB,nom]; N -[det]-> *}
    commands{del_feat N.nom}
  }
  
% All adjectives or verbs that govern a copula are considered as non nominals.
  rule cop_det{
    pattern{P[cat=ADJ|VERB,nom]; * -[comp:cop]-> P}
    commands{del_feat P.nom}
  }

  rule unity_num(feature $unite){
    pattern{N[cat=NUM,nom]; H[lemma=$unite]; H -[dep_SUD]-> N }
    commands{del_feat N.nom}
  }
#BEGIN
gramme
heure
litre
mètre
#END

  rule adv_de_nom(feature $adv){
    pattern{
     A[cat=ADV,lemma=$adv,!nom];
     A -[comp:obl]-> P; P[cat=ADP,lemma=de];
     N[cat=NOUN|NUM|SYM]; P -[comp]-> N
   }
   without{ * -[dep_SUD|mod]-> A}
   without{ A[lemma=moins|plus]; P0 -[comp]-> A; P0[lemma=en]}
   commands{ A.nom=y}
 }
#BEGIN
assez
autant
beaucoup
combien
davantage
moins
peu
plus
près
suffisamment
tant
tellement
trop
#END

}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package FR_mod {

  rule advmod {
    pattern {N[cat <> INDET]; e:N -[mod]-> M; M[cat=PRON|SYM, lemma="où"|"y"|"+"] }
    commands { del_edge e; add_edge N -[advmod]-> M }
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package FR_dep_SUD {
  rule aclrel{
    pattern{
      N[nom]; e: N -[dep_SUD]-> D; D[cat <> INDET];
      D -> PRO; PRO[PronType=Rel]
    }
    without{D[cat=Verb,PronType=Fin]}
    commands{del_edge e; add_edge N -[acl:relcl]-> D}
  }
  
  rule amod{
    pattern{H[cat=ADJ]; D[cat=ADJ]; e: H -[dep_SUD]-> D}
    without{D -[case|mark]-> *}
    commands{ del_edge e; add_edge H -[amod]-> D}
  }
  
  rule amod_de{
    pattern{
      H[cat=NOUN|PRON,lemma=chose|rien]; D[cat=ADJ]; e: H -[dep_SUD]-> D;
      D -[case]-> DE; DE[cat=ADP,lemma=de]
    }
    commands{ del_edge e; add_edge H -[amod]-> D}
  }

  rule nmod_de{
    pattern{
      H[cat <> INDET,nom]; D[cat=ADJ]; e: H -[dep_SUD]-> D;
      D -[case]-> DE; DE[cat=ADP,lemma=de]
    }
    without{H[lemma=chose|rien]}
    commands{ del_edge e; add_edge H -[nmod]-> D}
  }
  
  rule nmod_num1 {
    pattern { e:H -[dep_SUD]-> D; H[cat <> INDET, nom=y]; D[cat=NUM]; H << D }
    without{H[lemma=heure]}
    commands { del_edge e; add_edge H -[nmod]-> D }
  }
 
  rule nmod_num2 {
    pattern {
      e:H -[dep_SUD]-> D; H[cat <> INDET, nom=y]; H -[case]-> P;
      D[cat=NUM]; D << P; P << H }
    commands { del_edge e; add_edge H -[nmod]-> D }
  }

  rule nmod_num3{
    pattern { 
      N1[cat=NUM]; N2[cat=NUM]; e:N1 -[dep_SUD]-> N2;
      P[cat=ADP,lemma = "à"]; N2 -[case]-> P
    }
    commands{del_edge e; add_edge N1 -[nmod]-> N2}
  }
  
  rule nummod1{
    pattern { e:H -[dep_SUD]-> D; H[cat=ADJ]; D[cat=NUM]; D << H }
    without{D -[case]-> *}
    commands { del_edge e; add_edge H -[nummod]-> D }
  }

  rule obl_num{
    pattern { e:H -[dep_SUD]-> D; H[cat=ADJ|ADV|VERB]; D[cat=NUM]; H << D ; D -[case]-> *}
    commands { del_edge e; add_edge H -[obl]-> D }
  }

}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

strat FR_main {
  Seq (
    Onf (nom_init),
    Onf (FR_init),
    Onf (unchained_relations),
    Onf (reverse_case_mark),
    Onf (subj),
    Onf (det_nummod),
    Onf (comp),
    Onf (FR_mod),
    Onf (mod),
    Onf (FR_dep_SUD),
    Onf (dep_SUD),
    Onf (reverse_aux_cop),
    Onf (final),
  )
}

strat FR_main_specif_expr{
  Seq(
    Onf(specif_expr_init),
    FR_main,
    Onf(specif_expr_close)
  )
}


