%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
include "specif_expr.grs"

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
include "UD_to_SUD.grs"

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package FR_head_reverse {
% Impersonal construction with an adjective as a predicative complement and an infinitive introduced with "de" as a direct object.
%Ex : il est difficile de trouver du travail.
  rule impers_adj_de_inf{
    pattern{
     IL[cat=PRON,lemma=il,Gender=Masc,Number=Sing,Person=3];
     V[cat=AUX,lemma="être"]; V -[nsubj]-> IL;
     A[cat=ADJ]; V -[comp:pred]-> A;
     DE[cat=ADP,lemma=de]; e:A -[ccomp]-> DE;
     INF[cat=VERB,VerbForm=Inf]; DE -[comp]-> INF}
   commands{ del_edge e; add_edge V -[comp:obj]-> DE}
 }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Relations in SUD that require the use of a lexicon to be determined from UD relations.
package FR_relations {
% Relation between an adjective and an argument in the form of a finite clause, which is an oblique complement introduced with "que". By default, CCOMP relations are transformed into COMP:OBJ relations. In this case, they are transformed into COMP:OBL relations.
  rule adj_compobl_ccomp (lex from "lexicons/adj_with_deobj_fin-verb.lp") {
    pattern {
      H[cat=ADJ,lemma=lex.adj]; e:H -[ccomp]-> C;
      C[cat=SCONJ,lemma=que]}
    commands { del_edge e; add_edge H -[comp:obl]-> C }
  }
  
% Relation between a verb and an argument in the form of a finite clause, which is an oblique complement introduced with "que". By default, CCOMP relations are transformed into COMP:OBJ relations. In this case, they are transformed into COMP:OBL relations.
  rule verb_compobl_ccomp (lex from "lexicons/verb_with_deobj_fin-verb.lp") {
    pattern {
      H[cat=VERB,lemma=lex.verb]; e:H -[ccomp]-> C;
      C[cat=SCONJ,lemma=que]}
    commands { del_edge e; add_edge H -[comp:obl]-> C }
  }

% Relation between a verb with affix and an argument in the form of a finite clause, which is an oblique complement introduced with "que". By default, CCOMP relations are transformed into COMP:OBJ relations. In this case, they are transformed into COMP:OBL relations.
  rule verb_aff_compobl_ccomp (lex from "lexicons/aff_verb_with_deobj_fin-verb.lp") {
    pattern {
      H[cat=VERB,lemma=lex.verb]; e:H -[ccomp]-> C;
      C[cat=SCONJ,lemma=que];
      AFF[cat=PRON, lemma=lex.aff]; H -[expl]-> AFF}
    commands { del_edge e; add_edge H -[comp:obl]-> C }
  }
  
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package amalgam {
  rule prep_det {
    pattern {
      P [cat=ADP, phon= lex.prep];
      D [cat=DET, phon= lex.det];
      P < D;
    }
    commands {
      del_node D;
      P.phon = lex.amalgam;
      % The three next commands are needed to ensure correct CoNLLU output (without the x-y line for amalgam)
      del_feat P._UD_mw_fusion;
      del_feat P._UD_mw_span;
      del_feat P._UD_MISC_SpaceAfter;
    }
  }
#BEGIN lex
prep	det	amalgam
à	le	au
à	les	aux
de	le	du
de	les	des
#END

  rule prep_pro {
    pattern {
      PREP [cat=ADP, phon= lex.prep];
      PRON [cat=PRON, phon= lex.pron];
      PREP < PRON;
    }
    commands {
      del_node PRON;
      PREP.phon = lex.amalgam;
      % The three next commands are needed to ensure correct CoNLLU output (without the x-y line for amalgam)
      del_feat PREP._UD_mw_fusion;
      del_feat PREP._UD_mw_span;
      del_feat PREP._UD_MISC_SpaceAfter;
    }
  }
#BEGIN lex
prep	pron	amalgam
à	lequel	auquel
à	lesquels	auxquels
à	lesquelles	auxquelles
de	lequel	duquel
de	lesquelles	desquelles
#END
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
strat FR_main{
  Seq (
%    Onf (minimize_conj_dep),
    Onf (head_reverse),
    Onf (FR_head_reverse),
    Onf (gov_rise),
    Onf (FR_relations),
    Onf (relations),
    Onf (chained_relations),
    Onf (fail_label)
  )
}

strat FR_main_specif_expr{
  Seq(
    Onf(specif_expr_init),
    FR_main,
    Onf(specif_expr_close)
  )
}
