%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
include "specif_expr.grs"

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
include "UD_to_SUD.grs"



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package FR_relations {
  rule adj_compobl_ccomp (lex from "lexicons/adj_with_deobj_fin-verb.lp") {
    pattern {
      H[cat=ADJ,lemma=lex.adj]; e:H -[ccomp]-> C;
      C[cat=SCONJ,lemma=que]}
    commands { del_edge e; add_edge H -[comp:obl]-> C }
  }
  
  rule verb_compobl_ccomp (lex from "lexicons/verb_with_deobj_fin-verb.lp") {
    pattern {
      H[cat=VERB,lemma=lex.verb]; e:H -[ccomp]-> C;
      C[cat=SCONJ,lemma=que]}
    commands { del_edge e; add_edge H -[comp:obl]-> C }
  }

  rule verb_aff_compobl_ccomp (lex from "lexicons/aff_verb_with_deobj_fin-verb.lp") {
    pattern {
      H[cat=VERB,lemma=lex.verb]; e:H -[ccomp]-> C;
      C[cat=SCONJ,lemma=que];
      AFF[cat=PRON, lemma=lex.aff]; H -[expl]-> AFF}
    commands { del_edge e; add_edge H -[comp:obl]-> C }
  }
  
  rule det_nummod {
    pattern { e:H -[nummod]-> N; N << H}
    without { H -[det]-> *}
    without{ * -[det]-> H}
    without { H[cat=ADJ]; * -[amod|mod]-> H}
    commands { del_edge e; add_edge H -[det]-> N }
  }

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package correction{
  rule mod_adv{
    pattern{ ADV[cat=ADV]; e: H -[dep_SUD]-> ADV; ADV << H}
    commands{ del_edge e; add_edge H -[mod]-> ADV}
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package amalgam {
  rule prep_det {
    pattern {
      P [cat=ADP, phon= lex.prep];
      D [cat=DET, phon= lex.det];
      P < D;
    }
    commands {
      del_node D;
      P.phon = lex.amalgam;
      % The three next commands are needed to ensure correct CoNLLU output (without the x-y line for amalgam)
      del_feat P._UD_mw_fusion;
      del_feat P._UD_mw_span;
      del_feat P._UD_MISC_SpaceAfter;
    }
  }
#BEGIN lex
prep	det	amalgam
à	le	au
à	les	aux
de	le	du
de	les	des
#END

  rule prep_pro {
    pattern {
      PREP [cat=ADP, phon= lex.prep];
      PRON [cat=PRON, phon= lex.pron];
      PREP < PRON;
    }
    commands {
      del_node PRON;
      PREP.phon = lex.amalgam;
      % The three next commands are needed to ensure correct CoNLLU output (without the x-y line for amalgam)
      del_feat PREP._UD_mw_fusion;
      del_feat PREP._UD_mw_span;
      del_feat PREP._UD_MISC_SpaceAfter;
    }
  }
#BEGIN lex
prep	pron	amalgam
à	lequel	auquel
à	lesquels	auxquels
à	lesquelles	auxquelles
de	lequel	duquel
de	lesquelles	desquelles
#END
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
strat FR_main{
  Seq (
%    Onf (minimize_conj_dep),
    Onf (head_reverse),
    Onf (FR_relations),
    Onf (relations),
    Onf (gov_rise),
    Onf (chained_relations),
    Onf (correction),
    Onf (fail_label)
  )
}

strat FR_main_specif_expr{
  Seq(
    Onf(specif_expr_init),
    FR_main,
    Onf(specif_expr_close)
  )
}
