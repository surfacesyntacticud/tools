package UDPOS_init {
  rule case {
    pattern { X -[case]-> Y }
    without { Y [upos=ADP|PART] }
    without { Y [_MISC_MWEPOS=ADP|PART] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = ADP} % real value should be "ADP|PART"
  }

  rule mark {
    pattern { X -[mark]-> Y }
    without { Y [upos=ADP|SCONJ] }
    without { Y [_MISC_MWEPOS=ADP|SCONJ] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = ADP} % real value should be "ADP|SCONJ"
  }

  rule cop {
    pattern { X -[cop]-> Y }
    without { Y [upos=AUX] }
    without { Y [_MISC_MWEPOS=AUX] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = AUX}
  }

  rule aux {
    pattern { X -[re"aux.*"]-> Y }
    without { Y [upos=AUX] }
    without { Y [_MISC_MWEPOS=AUX] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = AUX}
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package UDPOS_after_reverse {
  rule amod {
    pattern { X -[amod]-> Y }
    without { Y [upos=ADJ] }
    without { Y [_MISC_MWEPOS=ADJ] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = ADJ}
  }

  rule advmod {
    pattern { X -[advmod]-> Y }
    without { Y [upos=ADV] }
    without { Y [_MISC_MWEPOS=ADV] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = ADV}
  }

  rule nsubj {
    pattern { X -[re"nsubj.*"]-> Y }
    without { Y [upos=NOUN|PROPN|PRON] }
    without { Y [_MISC_MWEPOS=NOUN|PROPN|PRON] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = NOUN}
  }

  rule csubj {
    pattern { X -[re"csubj.*"]-> Y }
    without { Y [upos=VERB] }
    without { Y [_MISC_MWEPOS=VERB] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = VERB}
  }

  rule acl_advcl {
    pattern { X -[acl|advcl]-> Y }
    without { Y [upos=VERB|ADJ] }
    without { Y [_MISC_MWEPOS=VERB|ADJ] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = VERB} % real value should be "VERB|ADJ"
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Move the dependents of a conjunction from the left conjunct to the right conjunct. Dependencies ADVCL, ADVMOD, APPOS, CCOMP, CONJ, DEP, DISCOURSE, PARATAXIS and PUNCT are not moved.
package minimize_conj_dep{

  rule min_acl{
    pattern{C1 -[conj]-> C2; e:C1 -[acl]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[acl]-> D}
  }
  
  rule min_aclrelcl{
    pattern{C1 -[conj]-> C2; e:C1 -[acl:relcl]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[acl:relcl]-> D}
  }

  rule min_amod{
    pattern{C1 -[conj]-> C2; e:C1 -[amod]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[amod]-> D}
  }
  
  rule min_flatname{
    pattern{C1 -[conj]-> C2; e:C1 -[flat:name]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[flat:name]-> D}
  }
  
  rule min_nmod{
    pattern{C1 -[conj]-> C2; e:C1 -[nmod]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[nmod]-> D}
  }
  
  rule min_nsubj{
    pattern{C1 -[conj]-> C2; e:C1 -[nsubj]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[nsubj]-> D}
  }
  
  rule min_nummod{
    pattern{C1 -[conj]-> C2; e:C1 -[nummod]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[nummod]-> D}
  }
  rule min_obj{
    pattern{C1 -[conj]-> C2; e:C1 -[obj]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[obj]-> D}
  }
  
  rule min_obl{
    pattern{C1 -[conj]-> C2; e:C1 -[obl]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[obl]-> D}
  }

  rule min_oblagent{
    pattern{C1 -[conj]-> C2; e:C1 -[obl:agent]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[obl:agent]-> D}
  }

  rule min_oblarg{
    pattern{C1 -[conj]-> C2; e:C1 -[obl:arg]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[obl:arg]-> D}
  }
  rule min_oblmod{
    pattern{C1 -[conj]-> C2; e:C1 -[obl:mod]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[obl:mod]-> D}
  }

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% For the auxiliaries, the rule of starting with the closest dependent does not work in the cases of extraposition of the predicate.
% Ex: fr-ud-test_00067-  ... ce que nous avons été ...
% The rule that works in all cases is based on an order between types of auxiliaries : cop < tense auxiliairy and passive auxiliary < tense auxiliary.
% The change of head for auxiliary relations must be processed together with the change of heads for case and mark relations. The rule is to start with the old dependent that is the closest to the old head while taking the order between types of auxiliaries into account.
% Ex: Il a été en retard ce matin. (case < cop < aux)
% Ex : Il part sans avoir été malade un seul jour. (cop < aux < mark)
% Counterex: il vient quel que soit le temps (cop < mark)
package head_reverse {
  rule aux {
    pattern {e:P -[aux]-> AUX}
    without { P-[mark]->X; AUX << X ; X << P} % Il a semblé que Marie arrivait.
    without { P-[mark]->X; AUX >> X ; X >> P}
    without {P -[aux|aux:pass|aux:caus|cop]-> AUX2}
    commands {
      del_edge e;
      add_edge AUX -[comp:aux]-> P;
      AUX.cat=VERB;
      shift_in P ==> AUX;
      shift_out P =[mark]=> AUX;
      shift_out P =[comp]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }

  rule auxpass {
    pattern {e:P -[aux:pass]-> AUX}
    commands {
      del_edge e;
      add_edge AUX -[comp:pass]-> P;
      AUX.cat=VERB;
      shift_in P ==> AUX;
      shift_out P =[aux|mark]=> AUX;
      shift_out P =[comp]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }
 
  rule auxcaus {
    pattern {e:P -[aux:caus]-> AUX}
    commands {
      del_edge e;
      add_edge AUX -[comp:caus]-> P;
      AUX.cat=VERB;
      shift_in P ==> AUX;
      shift_out P =[aux|mark]=> AUX;
      shift_out P =[obj:agent|obl:agent]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }

  rule cop {
    pattern {e:P -[cop]-> AUX}
    without { P-[mark]->X; AUX << X ; X << P}
    without { P-[mark]->X; AUX >> X ; X >> P}
    commands {
      del_edge e;
      add_edge AUX -[comp:cop]-> P;
      AUX.cat=VERB;
      shift_in P ==> AUX;
      shift_out P =[aux|mark]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }

  rule case{
    pattern { e:H-[case]->X1}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 << X2 ; X2 << H}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 >> X2 ; X2 >> H}
    without {  H -[punct]-> P; X1 << P; P << H}% no punctuation mark that has not to be shifted
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H==>X1;
      shift_out H =[aux|aux:pass|aux:caus|cop|mark|case]=> X1;
      shift_out H =[advcl|cc|csubj|nsubj|punct|root]=> X1;
    }
  }

  rule case_punct{
    pattern { e:H-[case]->X1;  H -[punct]-> P; X1 << P; P << H}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 << X2 ; X2 << H}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 >> X2 ; X2 >> H}
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H==>X1;
      shift_out H =[aux|aux:pass|aux:caus|cop|mark|case]=> X1;
      shift_out H =[advcl|cc|csubj|nsubj|punct|root]=> X1;
    }
  }
  
  rule mark{
    pattern { e:H-[mark]->X1}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 << X2 ; X2 << H}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 >> X2 ; X2 >> H}
    without {  H -[punct]-> P; X1 << P; P << H}% no punctuation mark that has not to be shifted
    without{ * -[cop]-> H} % Ex : quel que soit ...
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H==>X1;
      shift_out H =[aux|aux:pass|aux:caus|cop|mark|case]=> X1;
      shift_out H =[cc|punct|root]=> X1;
    }
  }

  rule mark_punct{
    pattern { e:H-[mark]->X1; H -[punct]-> P; X1 << P; P << H} % punctuation marks preceding the old head are not concerned with the head change; when there are two marks in this case, only one does not change its governor (UD_French-GSD@dev: fr-ud-dev_01506)
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 << X2 ; X2 << H}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 >> X2 ; X2 >> H}
    without{ * -[cop]-> H} % Ex : quel que soit ...
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H==>X1;
      shift_out H =[aux|aux:pass|aux:caus|cop|mark|case]=> X1;
      shift_out H =[cc|punct|root]=> X1;
    }
  }

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package FR_relations {
  rule adj_compobl_ccomp (feature $adj,$mood; file "lexicons/adj_with_deobj_fin-verb.lp") {
    pattern {
      H[cat=ADJ,lemma=$adj]; e:H -[ccomp]-> C;
      C[cat=SCONJ,lemma=que]}
    commands { del_edge e; add_edge H -[comp:obl]-> C }
  }
  
  rule verb_compobl_ccomp (feature $verb,$mood; file "lexicons/verb_with_deobj_fin-verb.lp") {
    pattern {
      H[cat=VERB,lemma=$verb]; e:H -[ccomp]-> C;
      C[cat=SCONJ,lemma=que]}
    commands { del_edge e; add_edge H -[comp:obl]-> C }
  }

  rule verb_aff_compobl_ccomp (feature $aff,$verb,$mood; file "lexicons/aff_verb_with_deobj_fin-verb.lp") {
    pattern {
      H[cat=VERB,lemma=$verb]; e:H -[ccomp]-> C;
      C[cat=SCONJ,lemma=que];
      AFF[cat=PRON, lemma=$aff]; H -[expl]-> AFF}
    commands { del_edge e; add_edge H -[comp:obl]-> C }
  }
  
  rule det_nummod {
    pattern { e:H -[nummod]-> N; N << H}
    without { H -[det]-> *}
    without{ * -[det]-> H}
    without { H[cat=ADJ]; * -[amod|mod]-> H}
    commands { del_edge e; add_edge H -[det]-> N }
  }

}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package relations {
  rule comp_agent {
    pattern { e:H -[obl:agent]-> C; }
    commands { del_edge e; add_edge H -[comp:agent]-> C }
  }
  rule comp_cleft {
    pattern { e:H -[advcl:cleft]-> C; }
    commands { del_edge e; add_edge H -[comp:cleft]-> C }
  }
  rule comp_lvc {
    pattern { e:H -[obj:lvc]-> C; }
    commands { del_edge e; add_edge H -[comp:lvc]-> C }
  }
  rule comp_obj {
    pattern { e:H -[obj|obj:agent|ccomp]-> C; C[cat <> ADP]; }
    commands { del_edge e; add_edge H -[comp:obj]-> C }
  }
  rule comp_obj_caus {
    pattern { e:H -[obj:agent]-> C; A -[comp:caus]-> H}
    commands { del_edge e; add_edge A -[comp:obj]-> C }
  }
  rule comp_obl {
    pattern { e:H -[obl:arg|iobj]-> C; }
    commands { del_edge e; add_edge H -[comp:obl]-> C }
  }
  rule comp_obl_ccomp {
    pattern { e:H -[ccomp]-> C; C[cat = ADP]; }
    commands { del_edge e; add_edge H -[comp:obl]-> C }
  }
  rule comp_rais {
    pattern { e:H -[xcomp]-> C; }
    commands { del_edge e; add_edge H -[comp:rais]-> C }
  }
  rule dep {
    pattern { e:H -[acl|acl:relcl|amod|nmod|nummod|obl]-> C; }
    commands { del_edge e; add_edge H -[dep_SUD]-> C }
  }
  rule dep_advmod {
    pattern { H[cat=NOUN|NUM|PRON|PROPN|SYM|X];  e:H -[advmod]-> C}
    commands { del_edge e; add_edge H -[dep_SUD]-> C }
  }
  rule mod {
    pattern { e:H -[advmod|advmod:neg|advcl|obl:mod]-> C; }
    without{ H[cat=NOUN|NUM|PRON|PROPN|SYM|X]}
    commands { del_edge e; add_edge H -[mod]-> C }
  }
  rule subj {
    pattern { e:H -[nsubj|nsubj:pass|csubj|csubj:pass]-> C}
    commands { del_edge e; add_edge H -[subj]-> C }
  }

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% In head changes, some dependents did not rise wrongly and it is necessary to correct it.
package gov_rise{

  rule conj_aux_rise{
    pattern{
      AUX -[comp:aux|comp:caus|comp:cop|comp:pass]-> V;
      e: V -[conj]-> V1; V1[VerbForm];
      AUX.VerbForm = V1.VerbForm
    }
    commands{del_edge e; add_edge AUX -[conj]-> V1}
  }

  rule conj_case_rise{
    pattern{
      PREP1[cat=ADP]; PREP1 -[comp]-> C;
      e: C -[conj]-> PREP2; PREP2[cat=ADP]
    }
    commands{del_edge e; add_edge PREP1 -[conj]-> PREP2}
  }

  rule conj_mark_rise{
    pattern{
      CS1[cat=SCONJ]; CS1 -[comp]-> C;
      e: C -[conj]-> CS2; CS2[cat=SCONJ]
    }
    commands{del_edge e; add_edge CS1 -[conj]-> CS2}
  }


  rule raise_dep{
    pattern {
      G -> D; D >> G; MOD[cat=ADV]; MOD << G;
      mod_rel:D -[dep_SUD]-> MOD
    }
    commands {
      del_edge mod_rel;
      add_edge G -[dep_SUD]-> MOD
    }
  }

% Modifiers preceding their governor with non projectivity rise to the governor of their governor.
  rule raise_mod{
    pattern {
      G -> D; D >> G; MOD << G;
      mod_rel:D -[mod]-> MOD
    }
    without { MOD [PronType=Rel]} 
    commands {
      del_edge mod_rel;
      add_edge G -[mod]-> MOD
    }
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dependencies of type CONJ, FIXED and FLAT:NAME grouped into a bouquet are reorganized into a chain.
package chained_relations {
  rule conj {
    pattern {H -[conj]-> D1;e: H -[conj]-> D2;D1 << D2}
    without {H -[conj]-> D;D1 << D; D << D2}
    without {H -[conj]-> D;D2 << D}
    commands {del_edge e;add_edge D1 -[conj]-> D2}
  }

  rule fixed {
    pattern {H -[fixed]-> D1;e: H -[fixed]-> D2;D1 << D2}
    without {H -[fixed]-> D;D1 << D; D << D2}
    without {H -[fixed]-> D;D2 << D;}
    commands {del_edge e;add_edge D1 -[fixed]-> D2}
  }

  rule flat_name {
    pattern {H -[flat:name]-> D1;e: H -[flat:name]-> D2;D1 << D2}
    without {H -[flat:name]-> D;D1 << D; D << D2}
    without {H -[flat:name]-> D;D2 << D}
    commands {del_edge e;add_edge D1 -[flat:name]-> D2}
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package correction{
  rule mod_adv{
    pattern{ ADV[cat=ADV]; e: H -[dep_SUD]-> ADV; ADV << H}
    commands{ del_edge e; add_edge H -[mod]-> ADV}
  }
  
  rule mwe_correct{
    pattern{H -> D; H[_MISC_INMWE=Yes]; D[_MISC_MWEPOS]}
    commands{
       H._MISC_MWEPOS=D._MISC_MWEPOS;D._MISC_INMWE=Yes;
       del_feat D._MISC_MWEPOS; del_feat H._MISC_INMWE
     }
   }

  rule title_correct{
    pattern{H -> D; H[_MISC_INTITLE=Yes]; D[_MISC_TITLE=Yes]}
    commands{
       H._MISC_TITLE= Yes; D._MISC_INTITLE=Yes;
       del_feat D._MISC_TITLE; del_feat H._MISC_INTITLE
     }
   }


}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package fail_label{

  rule FAIL_acl{
    pattern{e: G -[acl]-> D}
    commands{del_edge e; add_edge G -[FAIL_acl]-> D}
  }

  rule FAIL_advcl{
    pattern{e: G -[advcl]-> D}
    commands{del_edge e; add_edge G -[FAIL_advcl]-> D}
  }

  rule FAIL_advmod{
    pattern{e: G -[advmod]-> D}
    commands{del_edge e; add_edge G -[FAIL_advmod]-> D}
  }

  rule FAIL_amod{
    pattern{e: G -[amod]-> D}
    commands{del_edge e; add_edge G -[FAIL_amod]-> D}
  }

  rule FAIL_aux{
    pattern{e: G -[aux]-> D}
    commands{del_edge e; add_edge G -[FAIL_aux]-> D}
  }

  rule FAIL_case{
    pattern{e: G -[case]-> D}
    commands{del_edge e; add_edge G -[FAIL_case]-> D}
  }

  rule FAIL_ccomp{
    pattern{e: G -[ccomp]-> D}
    commands{del_edge e; add_edge G -[FAIL_ccomp]-> D}
  }

  rule FAIL_cop{
    pattern{e: G -[cop]-> D}
    commands{del_edge e; add_edge G -[FAIL_cop]-> D}
  }

  rule FAIL_csubj{
    pattern{e: G -[csubj]-> D}
    commands{del_edge e; add_edge G -[FAIL_csubj]-> D}
  }

  rule FAIL_iobj{
    pattern{e: G -[iobj]-> D}
    commands{del_edge e; add_edge G -[FAIL_iobj]-> D}
  }

  rule FAIL_mark{
    pattern{e: G -[mark]-> D}
    commands{del_edge e; add_edge G -[FAIL_mark]-> D}
  }

  rule FAIL_nmod{
    pattern{e: G -[nmod]-> D}
    commands{del_edge e; add_edge G -[FAIL_nmod]-> D}
  }

  rule FAIL_nsubj{
    pattern{e: G -[nsubj]-> D}
    commands{del_edge e; add_edge G -[FAIL_nsubj]-> D}
  }

  rule FAIL_nummod{
    pattern{e: G -[nummod]-> D}
    commands{del_edge e; add_edge G -[FAIL_nummod]-> D}
  }

  rule FAIL_obj{
    pattern{e: G -[obj]-> D}
    commands{del_edge e; add_edge G -[FAIL_obj]-> D}
  }

  rule FAIL_obl{
    pattern{e: G -[obl]-> D}
    commands{del_edge e; add_edge G -[FAIL_obl]-> D}
  }

  rule FAIL_xcomp{
    pattern{e: G -[xcomp]-> D}
    commands{del_edge e; add_edge G -[FAIL_xcomp]-> D}
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package amalgam {
  rule prep_det (feature $prep, $det, $amalgam) {
    pattern {
      P [cat=ADP, phon= $prep];
      D [cat=DET, phon= $det];
      P < D;
    }
    commands {
      del_node D;
      P.phon = $amalgam;
      % The three next commands are needed to ensure correct CoNLLU output (without the x-y line for amalgam)
      del_feat P._UD_mw_fusion;
      del_feat P._UD_mw_span;
      del_feat P._UD_MISC_SpaceAfter;
    }
  }
#BEGIN
à#le#au
à#les#aux
de#le#du
de#les#des
#END

  rule prep_pro (feature $prep, $pron, $amalgam) {
    pattern {
      PREP [cat=ADP, phon= $prep];
      PRON [cat=PRON, phon= $pron];
      PREP < PRON;
    }
    commands {
      del_node PRON;
      PREP.phon = $amalgam;
      % The three next commands are needed to ensure correct CoNLLU output (without the x-y line for amalgam)
      del_feat PREP._UD_mw_fusion;
      del_feat PREP._UD_mw_span;
      del_feat PREP._UD_MISC_SpaceAfter;
    }
  }
#BEGIN
à#lequel#auquel
à#lesquels#auxquels
à#lesquelles#auxquelles
de#lequel#duquel
de#lesquelles#desquelles
#END
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
strat main {
  Seq (
    %Onf (minimize_conj_dep),
    Onf (head_reverse),
    Onf (relations),
    Onf (gov_rise),% Package GOV_RISE must follow package HEAD_REVERSE because it corrects some wrong consequences of head changes.
    Onf (chained_relations),% Package CHAINED_RELATIONS must follow package GOV_RISE because it can entail a wrong coordination between two elements because of errors in head changes (UD_French-GS: fr-ud-dev_00131). 
    Onf (fail_label),
  )
}

strat FR_main {
  Seq (
    %Onf (minimize_conj_dep),
    Onf (head_reverse),
    Onf (FR_relations),
    Onf (relations),
    Onf (gov_rise),
    Onf (chained_relations),
    Onf (correction),
    Onf (fail_label),
  )
}

strat udpos {
  Seq (
    Onf (UDPOS_init),
    Onf (minimize_conj_dep),
    Onf (head_reverse),
    Onf (UDPOS_after_reverse),
    Onf (FR_relations),
    Onf (relations),
    Onf (gov_rise),
    Onf (chained_relations),
    Onf (correction),
    Onf (fail_label),
  )
}
