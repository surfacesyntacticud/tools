% Remove all EUD specific information
package eud_to_ud {
  rule deep { % remove add enhanced relations
    pattern { e:N -[re"E:.*"]-> M }
    commands { del_edge e}
  }

  rule empty { % remove empty nodes
    pattern { N [_UD_empty=Yes] }
    commands { del_node N }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Move the dependents of a conjunction from the left conjunct to the right conjunct. Dependencies CONJ, DISCOURSE, PARATAXIS and PUNCT are not moved.
package minimize_conj_dep {
  rule minimize {
    pattern {
      C1 -[conj]-> C2;
      e:C1 -[^conj|discourse|parataxis|punct]-> D; C2 << D}
    without { C1 -[conj]-> C; C2 << C }
    commands { add_edge e:C2 -> D; del_edge e }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% For the auxiliaries, the rule of starting with the closest dependent does not work in the cases of extraposition of the predicate.
% Ex: fr-ud-test_00067-  ... ce que nous avons été ...
% The rule that works in all cases is based on an order between types of auxiliaries : cop < tense auxiliairy and passive auxiliary < tense auxiliary for instance.
% The change of head for auxiliary relations must be processed together with the change of heads for case and mark relations. The rule is to start with the old dependent that is the closest to the old head while taking the order between types of auxiliaries into account.
% Ex: Il a été en retard ce matin. (case < cop < aux)
% Ex : Il part sans avoir été malade un seul jour. (cop < aux < mark)
% Ex: fr-ud-train_00086 - qui peut faire remonter sa lignée à un maître Chan, quelle que soit la nature de ses pratiques,... (mark < cop)
% Ex: fr-ud-train_01211 - cette crue était plus que cinquantennale ( mark < cop)
%=================================
% ORDER BETWEEN HEAD CHANGES :
% (1) aux:pass < aux , aux:caus < aux; cop < aux
% (2) case < aux, case < cop, case < mark; dependents of CASE relations are always closer to the head than AUX, COP and MARK relations.
% (3) aux < mark, aux:caus < mark, aux:pass < mark; dependents of AUX, AUX:CAUS and AUX:PASS relations are always closer to the head than MARK relations.
% (4) cop <> mark case <> case, mark <> mark; the order is determined by the order of proximity with respect the head
%===================================
package head_reverse {
  rule aux {
    pattern {e:H -[aux]-> AUX}
    without {H -[aux:pass|aux:caus|cop]-> AUX2} % AUX relations must be processed after AUX:CAUS, AUX:PASS and COP relations (point (1)).
    commands {
      del_edge e;
      add_edge AUX -[comp:aux]-> H;
      shift_in H ==> AUX;
      shift_out H =[mark]=> AUX;
      shift_out H =[advcl|advmod|cc|csubj|csubj:pass|dislocated|nsubj|nsubj:pass|obl:mod|punct|root]=> AUX;
    }
  }

  rule auxpass {
    pattern {e:H -[aux:pass]-> AUX}
    commands {
      del_edge e;
      add_edge AUX -[comp:pass]-> H;
      shift_in H ==> AUX;
      shift_out H =[aux|mark]=> AUX;
      shift_out H =[advcl|advmod|cc|csubj|csubj:pass|dislocated|nsubj|nsubj:pass|obl:mod|punct|root]=> AUX;
    }
  }

  rule auxcaus {
    pattern {e:H -[aux:caus]-> AUX}
    commands {
      del_edge e;
      add_edge AUX -[comp:caus]-> H;
      shift_in H ==> AUX;
      shift_out H =[aux|mark]=> AUX;
      shift_out H =[obj:agent|obl:agent]=> AUX;
      shift_out H =[advcl|advmod|cc|csubj|csubj:pass|dislocated|nsubj|nsubj:pass|obl:mod|punct|root]=> AUX;
    }
  }

  rule cop {
    pattern {e:H -[cop]-> AUX}
    without { H-[mark]->X; AUX << X ; X << H} % There is no MARK dependent between the head and the COP dependent (point (4)).
    without { H-[mark]->X; AUX >> X ; X >> H}
    commands {
      del_edge e;
      add_edge AUX -[comp:pred]-> H;
      shift_in H ==> AUX;
      shift_out H =[aux|mark]=> AUX;
      shift_out H =[advcl|advmod|cc|csubj|csubj:pass|dislocated|nsubj|nsubj:pass|obl:mod|punct|root]=> AUX;
    }
  }

  rule case{
    pattern { e:H-[case]->X1}
    without { H-[case]->X2; X1 << X2 ; X2 << H} % There is no other CASE dependent between the head and the COP dependent (point (4)).
    without { H-[case]->X2; X1 >> X2 ; X2 >> H}
    without { H -[punct]-> P; X1 << P; P << H} % no punctuation mark that has not to be shifted
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H ==> X1;
      shift_out H =[aux|case|cop|mark]=> X1;
      shift_out H =[advcl|cc|csubj|nsubj|obl:mod|punct|root]=> X1;
    }
  }

  rule case_punct{
    pattern { e:H-[case]->X1; H -[punct]-> P; X1 << P; P << H} % there is a punctuation mark that has not to be shifted
    without { H-[case]->X2; X1 << X2 ; X2 << H} % There is no other CASE dependent between the head and the COP dependent (point (4)).
    without { H-[case]->X2; X1 >> X2 ; X2 >> H}
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H ==> X1;
      shift_out H =[aux|case|cop|mark]=> X1;
      shift_out H =[advcl|cc|csubj|nsubj|obl:mod|punct|root]=> X1;
    }
  }

  rule mark{
    pattern {e:H-[mark]->X1}
    without { H-[aux|aux:caus|aux:pass|case|cop|mark]->X2; X1 << X2 ; X2 << H}% There is no AUX, AUX:CAUS, AUX:PASS (point (3)), CASE (point(2)), COP and other MARK (point(4)) dependents between the head and the mark dependent.
    without { H-[aux|aux:pass|aux:caus|case|cop|mark]->X2; X1 >> X2 ; X2 >> H}
    without {  H -[punct]-> P; X1 << P; P << H}% no punctuation mark that has not to be shifted
    without{ * -[cop]-> H} % Ex : quel que soit ...
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H ==> X1;
      shift_out H =[mark]=> X1;
      shift_out H =[cc|punct|root]=> X1;
    }
  }

  rule mark_punct{
    pattern {e:H-[mark]->X1; H -[punct]-> P; X1 << P; P << H} % punctuation marks preceding the old head are not concerned with the head change; when there are two marks in this case, only one does not change its governor (UD_French-GSD@dev: fr-ud-dev_01506)
    without { H-[aux|aux:pass|aux:caus|case|cop|mark]->X2; X1 << X2 ; X2 << H}% There is no AUX, AUX:CAUS, AUX:PASS (point (3)), CASE (point(2)), COP and other MARK (point(4)) dependents between the head and the mark dependent.
    without { H-[aux|aux:pass|aux:caus|case|cop|mark]->X2; X1 >> X2 ; X2 >> H}
    without{ * -[cop]-> H} % Ex : quel que soit ...
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H ==> X1;
      shift_out H =[mark]=> X1;
      shift_out H =[cc|punct|root]=> X1;
    }
  }
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% In head changes, some dependents did not rise wrongly and it is necessary to correct it.
package gov_rise{

% In a coordination, the head V1 of the second conjunct is a verb and the head V1 of the first conjunct depends on an auxiliary AUX, which has the same form as V2. The relation CONJ must raise from V1 to AUX.
  rule conj_aux_rise{
    pattern{
      AUX -[comp:aux|comp:caus|comp:pred|comp:pass]-> V1;
      e: V1 -[conj]-> V2; V2[VerbForm];
      AUX.VerbForm = V2.VerbForm
    }
    commands{del_edge e; add_edge AUX -[conj]-> V2}
  }

% In a coordination, the head PREP2 of the second conjunct is a preposition and the head C of the first conjunct depends on another preposition PREP1. The relation CONJ must raise from C to PREP1.
  rule conj_case_rise{
    pattern{
      PREP1[cat=ADP]; PREP1 -[comp]-> C;
      e: C -[conj]-> PREP2; PREP2[cat=ADP]
    }
    commands{del_edge e; add_edge PREP1 -[conj]-> PREP2}
  }

% In a coordination, the head CS2 of the second conjunct is a subordination conjunction and the head C of the first conjunct depends on another subordination conjunction CS1. The relation CONJ must raise from C to CS1.
  rule conj_mark_rise{
    pattern{
      CS1[cat=SCONJ]; CS1 -[comp]-> C;
      e: C -[conj]-> CS2; CS2[cat=SCONJ]
    }
    commands{del_edge e; add_edge CS1 -[conj]-> CS2}
  }

% With a left-headed relation H -> D, a dependant of D on the left of type "depSUD" is raised to H.
  rule left_raise_dep{
    pattern {
      H -> D; H << D; D1 << H;
      e:D -[acl|acl:relcl|nmod|obl|amod|nummod|advmod]-> D1; D1[cat=ADP|ADV|SCONJ]
    }
    commands {
      del_edge e;
      add_edge e: H -> D1
    }
  }

% With a left-headed relation H -> D, a dependant MOD of D on the left is raised to H.
  rule left_raise_mod{
    pattern {
      H -> D; H << D; MOD << H;
      e:D -[advcl|obl:mod|amod|nummod|advmod]-> MOD; MOD[cat=ADP|ADV|NOUN|SCONJ]
    }
    without { MOD [PronType=Rel] }
    without { MOD -[comp]-> PRO; PRO [PronType=Rel] }
    commands {
      del_edge e;
      add_edge e: H -> MOD
    }
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% UD relations are renamed as SUD relations.

package pre_relations {
  rule det_nummod {
    pattern { e:H -[nummod]-> N; N << H}
    without { H -[det]-> *}
    without { HH -[det]-> *; HH -> H; N << HH; }
    commands { del_edge e; add_edge H -[det]-> N }
  }
}

package relations {
  rule comp_agent {
    pattern { e:H -[obl:agent]-> D; }
    commands { del_edge e; add_edge H -[comp:agent]-> D }
  }

  rule comp_cleft {
    pattern { e:H -[advcl:cleft]-> D; }
    commands { del_edge e; add_edge H -[comp:cleft]-> D }
  }

  rule comp_lvc {
    pattern { e:H -[obj:lvc]-> D; }
    commands { del_edge e; add_edge H -[comp:lvc]-> D }
  }

  rule comp_obj {
    pattern { e:H -[obj|obj:agent]-> D; }
    commands { del_edge e; add_edge H -[comp:obj]-> D }
  }

  rule comp_obl {
    pattern { e:H -[obl:arg|iobj]-> D; }
    commands { del_edge e; add_edge H -[comp:obl]-> D }
  }

  rule comp_pred {
    pattern { e:H -[xcomp]-> D; }
    commands { del_edge e; add_edge H -[comp:pred]-> D }
  }

  rule dep {
    pattern { e:H -[acl|acl:relcl|nmod|obl]-> D}
    commands { del_edge e; add_edge H -[dep_SUD]-> D }
  }

  rule mod {
    pattern { e:H -[advcl|obl:mod]-> D; }
    commands { del_edge e; add_edge H -[mod]-> D }
  }

  rule subj {
    pattern { e:H -[nsubj|nsubj:pass|csubj|csubj:pass]-> D}
    commands { del_edge e; add_edge H -[subj]-> D }
  }




  rule comp_obj_ccomp {
    pattern { e:H -[ccomp]-> D; D[upos <> ADP]; }
    commands { del_edge e; add_edge H -[comp:obj]-> D }
  }

  rule comp_obl_ccomp {
    pattern { e:H -[ccomp]-> D; D[upos = ADP]; }
    commands { del_edge e; add_edge H -[comp:obl]-> D }
  }



  rule dep_not_adj {
    pattern { H[cat<>ADJ]; e:H -[amod|nummod]-> D}
    commands { del_edge e; add_edge H -[dep_SUD]-> D }
  }

% Adjectives with determiners are considered as nominals.
  rule dep_adj {
    pattern { H[cat=ADJ]; H -[det]-> *; e:H -[amod|nummod]-> D}
    commands { del_edge e; add_edge H -[dep_SUD]-> D }
  }

  rule mod_adj {
    pattern {H[cat=ADJ]; e:H -[amod|nummod]-> D }
    without{ H -[det]-> *}
    commands { del_edge e; add_edge H -[mod]-> D }
  }


  rule dep_advmod {
    pattern { H[cat=NOUN|NUM|PRON|PROPN|SYM|X]; e:H -[advmod]-> D}
    commands { del_edge e; add_edge H -[dep_SUD]-> D }
  }

  rule mod_advmod {
    pattern { e:H -[advmod]-> D; }
    without{ H[cat=NOUN|NUM|PRON|PROPN|SYM|X]}
    commands { del_edge e; add_edge H -[mod]-> D }
  }


}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dependencies of type CONJ, FIXED and FLAT:NAME grouped into a bouquet are reorganized into a chain.
package chained_relations {
  rule conj {
    pattern {H -[conj]-> D1;e: H -[conj]-> D2;D1 << D2}
    without {H -[conj]-> D;D1 << D; D << D2}
    without {H -[conj]-> D;D2 << D}
    commands {del_edge e;add_edge D1 -[conj]-> D2}
  }

  rule fixed {
    pattern {H -[fixed]-> D1;e: H -[fixed]-> D2;D1 << D2}
    without {H -[fixed]-> D;D1 << D; D << D2}
    without {H -[fixed]-> D;D2 << D;}
    commands {del_edge e;add_edge D1 -[fixed]-> D2}
  }

  rule flat_name {
    pattern {H -[flat:name]-> D1;e: H -[flat:name]-> D2;D1 << D2}
    without {H -[flat:name]-> D;D1 << D; D << D2}
    without {H -[flat:name]-> D;D2 << D}
    commands {del_edge e;add_edge D1 -[flat:name]-> D2}
  }
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% UD relations X that fail to be renamed as SUD relations are marked FAIL_X.
package fail_label{

  rule FAIL_acl{
    pattern{e: G -[acl]-> D}
    commands{del_edge e; add_edge G -[FAIL_acl]-> D}
  }

  rule FAIL_acl_relcl{
    pattern{e: G -[acl:relcl]-> D}
    commands{del_edge e; add_edge G -[FAIL_acl:relcl]-> D}
  }

  rule FAIL_advcl{
    pattern{e: G -[advcl]-> D}
    commands{del_edge e; add_edge G -[FAIL_advcl]-> D}
  }

  rule FAIL_advcl_cleft{
    pattern{e: G -[advcl:cleft]-> D}
    commands{del_edge e; add_edge G -[FAIL_advcl:cleft]-> D}
  }

  rule FAIL_advmod{
    pattern{e: G -[advmod]-> D}
    commands{del_edge e; add_edge G -[FAIL_advmod]-> D}
  }

  rule FAIL_amod{
    pattern{e: G -[amod]-> D}
    commands{del_edge e; add_edge G -[FAIL_amod]-> D}
  }

  rule FAIL_aux{
    pattern{e: G -[aux]-> D}
    commands{del_edge e; add_edge G -[FAIL_aux]-> D}
  }

  rule FAIL_aux_pass{
    pattern{e: G -[aux:pass]-> D}
    commands{del_edge e; add_edge G -[FAIL_aux:pass]-> D}
  }

  rule FAIL_aux_caus{
    pattern{e: G -[aux:caus]-> D}
    commands{del_edge e; add_edge G -[FAIL_aux:caus]-> D}
  }

  rule FAIL_case{
    pattern{e: G -[case]-> D}
    commands{del_edge e; add_edge G -[FAIL_case]-> D}
  }

  rule FAIL_ccomp{
    pattern{e: G -[ccomp]-> D}
    commands{del_edge e; add_edge G -[FAIL_ccomp]-> D}
  }

  rule FAIL_cop{
    pattern{e: G -[cop]-> D}
    commands{del_edge e; add_edge G -[FAIL_cop]-> D}
  }

  rule FAIL_csubj{
    pattern{e: G -[csubj]-> D}
    commands{del_edge e; add_edge G -[FAIL_csubj]-> D}
  }

  rule FAIL_csubj_pass{
    pattern{e: G -[csubj:pass]-> D}
    commands{del_edge e; add_edge G -[FAIL_csubj:pass]-> D}
  }

  rule FAIL_iobj{
    pattern{e: G -[iobj]-> D}
    commands{del_edge e; add_edge G -[FAIL_iobj]-> D}
  }

  rule FAIL_mark{
    pattern{e: G -[mark]-> D}
    commands{del_edge e; add_edge G -[FAIL_mark]-> D}
  }

  rule FAIL_nmod{
    pattern{e: G -[nmod]-> D}
    commands{del_edge e; add_edge G -[FAIL_nmod]-> D}
  }

  rule FAIL_nsubj{
    pattern{e: G -[nsubj]-> D}
    commands{del_edge e; add_edge G -[FAIL_nsubj]-> D}
  }

  rule FAIL_nsubj_pass{
    pattern{e: G -[nsubj:pass]-> D}
    commands{del_edge e; add_edge G -[FAIL_nsubj:pass]-> D}
  }

  rule FAIL_nummod{
    pattern{e: G -[nummod]-> D}
    commands{del_edge e; add_edge G -[FAIL_nummod]-> D}
  }

  rule FAIL_obj{
    pattern{e: G -[obj]-> D}
    commands{del_edge e; add_edge G -[FAIL_obj]-> D}
  }

  rule FAIL_obj_agent{
    pattern{e: G -[obj:agent]-> D}
    commands{del_edge e; add_edge G -[FAIL_obj_agent]-> D}
  }

  rule FAIL_obl{
    pattern{e: G -[obl]-> D}
    commands{del_edge e; add_edge G -[FAIL_obl]-> D}
  }

  rule FAIL_obl_mod{
    pattern{e: G -[obl:mod]-> D}
    commands{del_edge e; add_edge G -[FAIL_obl:mod]-> D}
  }

  rule FAIL_obl_arg{
    pattern{e: G -[obl:arg]-> D}
    commands{del_edge e; add_edge G -[FAIL_obl:arg]-> D}
  }

  rule FAIL_obl_agent{
    pattern{e: G -[obl:agent]-> D}
    commands{del_edge e; add_edge G -[FAIL_obl_agent]-> D}
  }

  rule FAIL_xcomp{
    pattern{e: G -[xcomp]-> D}
    commands{del_edge e; add_edge G -[FAIL_xcomp]-> D}
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
strat main {
  Seq (
    Onf (eud_to_ud),
    Onf (minimize_conj_dep),
    Onf (head_reverse),
    Onf (gov_rise),% Package GOV_RISE must follow package HEAD_REVERSE because it corrects some wrong consequences of head changes.
    Onf (pre_relations), Onf (relations), % Package RELATIONS must follow package GOV_RISE because this package entails the change of catagory for the source and the target of some relaitions.
    Onf (chained_relations),% Package CHAINED_RELATIONS must follow package GOV_RISE because it can entail a wrong coordination between two elements because of errors in head changes (UD_French-GS: fr-ud-dev_00131).
    Onf (fail_label),
  )
}
