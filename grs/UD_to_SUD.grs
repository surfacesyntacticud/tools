% Remove all EUD specific information
package eud_to_ud {
  rule deep { % remove add enhanced relations
    pattern { e:N -[re"E:.*"]-> M }
    commands { del_edge e}
  }

  rule empty { % remove empty nodes
    pattern { N [_UD_empty=Yes] }
    commands { del_node N }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Move the dependents of a conjunction from the left conjunct to the right conjunct. Dependencies CONJ, DISCOURSE, PARATAXIS and PUNCT are not moved.
package minimize_conj_dep {
  rule minimize {
    pattern {
      C1 -[conj]-> C2;
      e:C1 -[^conj|discourse|parataxis|punct]-> D; C2 << D}
    without { C1 -[conj]-> C; C2 << C }
    commands { add_edge e:C2 -> D; del_edge e }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

package remove_extension_on_reverted_relations {
  package protect {
    rule auxcaus {
      pattern { e:H -[aux:caus]-> D }
      commands { del_edge e; add_edge H -[caus]-> D }
    }
    rule auxpass {
      pattern { e:H -[aux:pass]-> D }
      commands { del_edge e; add_edge H -[pass]-> D }
    }
  }

  package map {
    rule aux {
      pattern { e:H -[re"aux:.*"]-> D }
      commands { del_edge e; add_edge H -[aux]-> D }
    }
    rule cop {
      pattern { e:H -[re"cop:.*"]-> D }
      commands { del_edge e; add_edge H -[cop]-> D }
    }
    rule case {
      pattern { e:H -[re"case:.*"]-> D }
      commands { del_edge e; add_edge H -[case]-> D }
    }
    rule mark {
      pattern { e:H -[re"mark:.*"]-> D }
      commands { del_edge e; add_edge H -[mark]-> D }
    }
  }

  package restore {
    rule auxcaus {
      pattern { e:H -[caus]-> D }
      commands { del_edge e; add_edge H -[aux:caus]-> D }
    }
    rule auxpass {
      pattern { e:H -[pass]-> D }
      commands { del_edge e; add_edge H -[aux:pass]-> D }
    }
  }

  strat s { Seq (Onf (protect), Onf (map), Onf (restore)) }
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% For the auxiliaries, the rule of starting with the closest dependent does not work in the cases of extraposition of the predicate.
% Ex: fr-ud-test_00067-  ... ce que nous avons été ...
% The rule that works in all cases is based on an order between types of auxiliaries : cop < tense auxiliairy and passive auxiliary < tense auxiliary for instance.
% The change of head for auxiliary relations must be processed together with the change of heads for case and mark relations. The rule is to start with the old dependent that is the closest to the old head while taking the order between types of auxiliaries into account.
% Ex: Il a été en retard ce matin. (case < cop < aux)
% Ex : Il part sans avoir été malade un seul jour. (cop < aux < mark)
% Ex: fr-ud-train_00086 - qui peut faire remonter sa lignée à un maître Chan, quelle que soit la nature de ses pratiques,... (mark < cop)
% Ex: fr-ud-train_01211 - cette crue était plus que cinquantennale ( mark < cop)
%=================================
% ORDER BETWEEN HEAD CHANGES :
% (1) aux:pass < aux , aux:caus < aux; cop < aux
% (2) case < aux, case < cop, case < mark; dependents of CASE relations are always closer to the head than AUX, COP and MARK relations.
% (3) aux < mark, aux:caus < mark, aux:pass < mark; dependents of AUX, AUX:CAUS and AUX:PASS relations are always closer to the head than MARK relations.
% (4) cop <> mark case <> case, mark <> mark; the order is determined by the order of proximity with respect the head
%===================================
package head_reverse {
  rule aux {
    pattern {e:H -[aux]-> AUX}
    without {H -[aux:pass|aux:caus|cop]-> AUX2} % AUX relations must be processed after AUX:CAUS, AUX:PASS and COP relations (point (1)).
    commands {
      del_edge e;
      add_edge AUX -[comp:aux]-> H;
      shift_in H ==> AUX;
      shift_out H =[mark]=> AUX;
      shift_out H =[advcl|advmod|cc|csubj|csubj:pass|dislocated|nsubj|nsubj:pass|obl:mod|parataxis|punct|root]=> AUX;
    }
  }

  rule auxpass {
    pattern {e:H -[aux:pass]-> AUX}
    commands {
      del_edge e;
      add_edge AUX -[comp:pass]-> H;
      shift_in H ==> AUX;
      shift_out H =[aux|mark]=> AUX;
      shift_out H =[advcl|advmod|cc|csubj|csubj:pass|dislocated|nsubj|nsubj:pass|obl:mod|parataxis|punct|root]=> AUX;
    }
  }

  rule auxcaus {
    pattern {e:H -[aux:caus]-> AUX}
    commands {
      del_edge e;
      add_edge AUX -[comp:caus]-> H;
      shift_in H ==> AUX;
      shift_out H =[aux|mark]=> AUX;
      shift_out H =[iobj:agent|obj:agent|obl:agent]=> AUX;
      shift_out H =[advcl|advmod|cc|csubj|csubj:pass|dislocated|nsubj|nsubj:caus|nsubj:pass|obl:mod|parataxis|punct|root]=> AUX;
    }
  }

  rule cop {
    pattern {e:H -[cop]-> AUX}
    without { H-[mark]->X; AUX << X ; X << H} % There is no MARK dependent between the head and the COP dependent (point (4)).
    without { H-[mark]->X; AUX >> X ; X >> H}
    commands {
      del_edge e;
      add_edge AUX -[comp:pred]-> H;
      shift_in H ==> AUX;
      shift_out H =[aux|mark]=> AUX;
      shift_out H =[advcl|advmod|cc|csubj|csubj:pass|dislocated|nsubj|nsubj:pass|obl:mod|parataxis|punct|root]=> AUX;
    }
  }

  rule case{
    pattern { e:H-[case]->X1; X1[cat <> PART]}
    without { H-[case]->X2; X1 << X2 ; X2 << H} % There is no other CASE dependent between the head and the COP dependent (point (4)).
    without { H-[case]->X2; X1 >> X2 ; X2 >> H}
    without { H -[punct]-> P; X1 << P; P << H} % no punctuation mark that has not to be shifted
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H ==> X1;
      shift_out H =[aux|case|cop|mark]=> X1;
      shift_out H =[advcl|cc|csubj|nsubj|obl:mod|punct|root]=> X1;
    }
  }

  rule case_punct{
    pattern { e:H-[case]->X1; H -[punct]-> P; X1[cat <> PART]; X1 << P; P << H} % there is a punctuation mark that has not to be shifted
    without { H-[case]->X2; X1 << X2 ; X2 << H} % There is no other CASE dependent between the head and the COP dependent (point (4)).
    without { H-[case]->X2; X1 >> X2 ; X2 >> H}
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H ==> X1;
      shift_out H =[aux|case|cop|mark]=> X1;
      shift_out H =[advcl|cc|csubj|nsubj|obl:mod|punct|root]=> X1;
    }
  }

  rule mark{
    pattern {e:H-[mark]->X1}
    without { H-[aux|aux:caus|aux:pass|case|cop|mark]->X2; X1 << X2 ; X2 << H}% There is no AUX, AUX:CAUS, AUX:PASS (point (3)), CASE (point(2)), COP and other MARK (point(4)) dependents between the head and the mark dependent.
    without { H-[aux|aux:pass|aux:caus|case|cop|mark]->X2; X1 >> X2 ; X2 >> H}
    without {  H -[punct]-> P; X1 << P; P << H}% no punctuation mark that has not to be shifted
    without{ * -[cop]-> H} % Ex : quel que soit ...
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H ==> X1;
      shift_out H =[mark]=> X1;
      shift_out H =[cc|punct|root]=> X1;
    }
  }

  rule mark_punct{
    pattern {e:H-[mark]->X1; H -[punct]-> P; X1 << P; P << H} % punctuation marks preceding the old head are not concerned with the head change; when there are two marks in this case, only one does not change its governor (UD_French-GSD@dev: fr-ud-dev_01506)
    without { H-[aux|aux:pass|aux:caus|case|cop|mark]->X2; X1 << X2 ; X2 << H}% There is no AUX, AUX:CAUS, AUX:PASS (point (3)), CASE (point(2)), COP and other MARK (point(4)) dependents between the head and the mark dependent.
    without { H-[aux|aux:pass|aux:caus|case|cop|mark]->X2; X1 >> X2 ; X2 >> H}
    without{ * -[cop]-> H} % Ex : quel que soit ...
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H ==> X1;
      shift_out H =[mark]=> X1;
      shift_out H =[cc|punct|root]=> X1;
    }
  }
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% In head changes, some dependents did not rise wrongly and it is necessary to correct it.
package gov_rise{

% In a coordination, the head V1 of the second conjunct is a verb and the head V1 of the first conjunct depends on an auxiliary AUX, which has the same form as V2. The relation CONJ must raise from V1 to AUX.
  rule conj_aux_rise{
    pattern{
      AUX -[comp:aux|comp:caus|comp:pred|comp:pass]-> V1;
      e: V1 -[conj]-> V2; V2[VerbForm];
      AUX.VerbForm = V2.VerbForm
    }
    commands{del_edge e; add_edge AUX -[conj]-> V2}
  }

% In a coordination, the head PREP2 of the second conjunct is a preposition and the head C of the first conjunct depends on another preposition PREP1. The relation CONJ must raise from C to PREP1.
  rule conj_case_rise{
    pattern{
      PREP1[cat=ADP]; PREP1 -[comp]-> C;
      e: C -[conj]-> PREP2; PREP2[cat=ADP]
    }
    commands{del_edge e; add_edge PREP1 -[conj]-> PREP2}
  }

% In a coordination, the head CS2 of the second conjunct is a subordination conjunction and the head C of the first conjunct depends on another subordination conjunction CS1. The relation CONJ must raise from C to CS1.
  rule conj_mark_rise{
    pattern{
      CS1[cat=SCONJ]; CS1 -[comp]-> C;
      e: C -[conj]-> CS2; CS2[cat=SCONJ]
    }
    commands{del_edge e; add_edge CS1 -[conj]-> CS2}
  }

% With a left-headed relation H -> D, a dependant of D on the left of a type that may be modifier is raised to H.
  rule left_raise{
    pattern {
      H -[re"comp.*"]-> D; H << D; D1 << H;
      e:D -[acl|acl:relcl|advcl|advmod|amod|nmod|obl|obl:mod]-> D1; D1[cat=ADP|ADV|SCONJ|SYM]
    }
    commands {
      del_edge e;
      add_edge e: H -> D1
    }
  }

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% UD sub-relations  are renamed as  SUD sub-relations.
package sub_relations {
  rule comp_agent {
    pattern { e:H -[iobj:agent|obl:agent]-> D; }
    commands { del_edge e; add_edge H -[comp:agent]-> D }
  }

  rule comp_cleft {
    pattern { e:H -[advcl:cleft]-> D; }
    commands { del_edge e; add_edge H -[comp:cleft]-> D }
  }

  rule comp_lvc {
    pattern { e:H -[obj:lvc]-> D; }
    commands { del_edge e; add_edge H -[comp:lvc]-> D }
  }

  rule comp_obl {
    pattern { e:H -[obl:arg]-> D; }
    commands { del_edge e; add_edge H -[comp:obl]-> D }
  }

  rule mod {
    pattern { e:H -[acl:relcl|obl:mod]-> D; }
    commands { del_edge e; add_edge H -[mod]-> D }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% UD relations are renamed as SUD relations or sub-relations.
package relations {
  rule comp_obj {
    pattern { e:H -[re"obj.*"]-> D; }
    commands { del_edge e; add_edge H -[comp:obj]-> D }
  }

  rule comp_obl {
    pattern { e:H -[re"iobj.*"]-> D; }
    commands { del_edge e; add_edge H -[comp:obl]-> D }
  }

  rule comp_pred {
    pattern { e:H -[re"xcomp.*"]-> D; }
    commands { del_edge e; add_edge H -[comp:pred]-> D }
  }
  
  rule comp_obj_ccomp {
    pattern { e:H -[re"ccomp.*"]-> D; D[upos <> ADP]; }
    commands { del_edge e; add_edge H -[comp:obj]-> D }
  }

  rule comp_obl_ccomp {
    pattern { e:H -[re"ccomp.*"]-> D; D[upos = ADP]; }
    commands { del_edge e; add_edge H -[comp:obl]-> D }
  }
  
  rule det_nummod {
    pattern { e:H -[re"nummod.*"]-> D; D << H}
    without { H -[det]-> *}
    commands { del_edge e; add_edge H -[det]-> D }
  }

  rule mod {
    pattern { e:H -[re"\(advcl\|advmod\|amod\).*"]-> D; }
    commands { del_edge e; add_edge H -[mod]-> D }
  }

  rule mod_noun {
    pattern { e:H -[re"\(acl\|nmod\).*"]-> D}
    without{ D -[case|mark]-> *}
    commands { del_edge e; add_edge H -[udep]-> D }
  }
  
  rule mod_nummod1 {
    pattern {e:H -[re"nummod.*"]-> D; H << D }
    without{ H -[det]-> *}
    commands { del_edge e; add_edge H -[mod]-> D }
  }
  
  rule mod_nummod2 {
    pattern {e:H -[re"nummod.*"]-> D; H -[det]-> * }
    commands { del_edge e; add_edge H -[mod]-> D }
  }
  
  rule pcase {
    pattern {e:H -[re"case.*"]-> D; D[cat=PART] }
    commands { del_edge e; add_edge H -[pcase]-> D }
  }
  
  rule subj {
    pattern { e:H -[re"\(nsubj\|csubj\).*"]-> D}
    commands { del_edge e; add_edge H -[subj]-> D }
  }
  
  rule udep {
    pattern { e:H -[re"\(acl\|nmod\).*"]-> D; D -[case|mark]-> *}
    commands { del_edge e; add_edge H -[udep]-> D }
  }

  rule udep_obl {
    pattern { e:H -[re"obl.*"]-> D}
    commands { del_edge e; add_edge H -[udep]-> D }
  }
  rule unk {
    pattern { e:H -[re"dep.*"]-> D; }
    commands { del_edge e; add_edge H -[unk]-> D }
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dependencies of type CONJ, FIXED and FLAT:NAME grouped into a bouquet are reorganized into a chain.
package chained_relations {
  rule conj {
    pattern {H -[conj]-> D1;e: H -[conj]-> D2;D1 << D2}
    without {H -[conj]-> D;D1 << D; D << D2}
    without {H -[conj]-> D;D2 << D}
    commands {del_edge e;add_edge D1 -[conj]-> D2}
  }

  rule fixed {
    pattern {H -[fixed]-> D1;e: H -[fixed]-> D2;D1 << D2}
    without {H -[fixed]-> D;D1 << D; D << D2}
    without {H -[fixed]-> D;D2 << D;}
    commands {del_edge e;add_edge D1 -[fixed]-> D2}
  }

  rule flat_name {
    pattern {H -[flat:name]-> D1;e: H -[flat:name]-> D2;D1 << D2}
    without {H -[flat:name]-> D;D1 << D; D << D2}
    without {H -[flat:name]-> D;D2 << D}
    commands {del_edge e;add_edge D1 -[flat:name]-> D2}
  }
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
strat main {
  Seq (
    Onf (eud_to_ud),
    Onf (minimize_conj_dep),
    remove_extension_on_reverted_relations.s,
    Onf (head_reverse),
    Onf (gov_rise),% Package GOV_RISE must follow package HEAD_REVERSE because it corrects some wrong consequences of head changes.
    Onf (sub_relations),
    Onf (relations), % Package RELATIONS must follow package GOV_RISE because this package entails the change of catagory for the source and the target of some relaitions.

    Onf (chained_relations),% Package CHAINED_RELATIONS must follow package GOV_RISE because it can entail a wrong coordination between two elements because of errors in head changes (UD_French-GS: fr-ud-dev_00131).
  )
}
