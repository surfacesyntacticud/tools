% Remove all EUD specific information
package eud_to_ud {
  rule deep { % remove add enhanced relations
    pattern { e:N -[re"E:.*"]-> M }
    commands { del_edge e}
  }

  rule empty { % remove empty nodes
    pattern { N [_UD_empty=Yes] }
    commands { del_node N }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Move the dependents of a conjunction from the left conjunct to the right conjunct. Dependencies CONJ, DISCOURSE, PARATAXIS and PUNCT are not moved.
package minimize_conj_dep{

  rule minimize{
    pattern{
      C1 -[conj]-> C2;
      e:C1 -[^ conj|discourse|parataxis|punct]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{add_edge e:C2 -> D; del_edge e}
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% For the auxiliaries, the rule of starting with the closest dependent does not work in the cases of extraposition of the predicate.
% Ex: fr-ud-test_00067-  ... ce que nous avons été ...
% The rule that works in all cases is based on an order between types of auxiliaries : cop < tense auxiliairy and passive auxiliary < tense auxiliary.
% The change of head for auxiliary relations must be processed together with the change of heads for case and mark relations. The rule is to start with the old dependent that is the closest to the old head while taking the order between types of auxiliaries into account.
% Ex: Il a été en retard ce matin. (case < cop < aux)
% Ex : Il part sans avoir été malade un seul jour. (cop < aux < mark)
% Counterex: il vient quel que soit le temps (cop < mark)
package head_reverse {
  rule aux {
    pattern {e:P -[aux]-> AUX}
    without { P-[mark|aux]->X; AUX << X ; X << P} % Il a semblé que Marie arrivait.
    without { P-[mark|aux]->X; AUX >> X ; X >> P}
    without {P -[aux:pass|aux:caus|cop]-> AUX2}
    commands {
      del_edge e;
      add_edge AUX -[comp:aux]-> P;
      shift_in P ==> AUX;
      shift_out P =[mark]=> AUX;
      shift_out P =[comp]=> AUX;
      shift_out P =[aux]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }

  rule auxpass {
    pattern {e:P -[aux:pass]-> AUX}
    commands {
      del_edge e;
      add_edge AUX -[comp:pass]-> P;
      shift_in P ==> AUX;
      shift_out P =[aux|mark]=> AUX;
      shift_out P =[comp]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }

  rule auxcaus {
    pattern {e:P -[aux:caus]-> AUX}
    commands {
      del_edge e;
      add_edge AUX -[comp:caus]-> P;
      shift_in P ==> AUX;
      shift_out P =[aux|mark]=> AUX;
      shift_out P =[obj:agent|obl:agent]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }

  rule cop {
    pattern {e:P -[cop]-> AUX}
    without { P-[mark]->X; AUX << X ; X << P}
    without { P-[mark]->X; AUX >> X ; X >> P}
    commands {
      del_edge e;
      add_edge AUX -[comp:pred]-> P;
      shift_in P ==> AUX;
      shift_out P =[aux|mark]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }

  rule case{
    pattern { e:H-[case]->X1}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 << X2 ; X2 << H}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 >> X2 ; X2 >> H}
    without {  H -[punct]-> P; X1 << P; P << H}% no punctuation mark that has not to be shifted
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H==>X1;
      shift_out H =[aux|aux:pass|aux:caus|cop|mark|case]=> X1;
      shift_out H =[advcl|cc|csubj|nsubj|root]=> X1;
    }
  }

  rule case_punct{
    pattern { e:H-[case]->X1;  H -[punct]-> P; X1 << P; P << H}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 << X2 ; X2 << H}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 >> X2 ; X2 >> H}
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H==>X1;
      shift_out H =[aux|aux:pass|aux:caus|cop|mark|case]=> X1;
      shift_out H =[advcl|cc|csubj|nsubj|punct|root]=> X1;
    }
  }

  rule mark{
    pattern { e:H-[mark]->X1}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 << X2 ; X2 << H}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 >> X2 ; X2 >> H}
    without {  H -[punct]-> P; X1 << P; P << H}% no punctuation mark that has not to be shifted
    without{ * -[cop]-> H} % Ex : quel que soit ...
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H==>X1;
      shift_out H =[aux|aux:pass|aux:caus|cop|mark|case]=> X1;
      shift_out H =[cc|punct|root]=> X1;
    }
  }

  rule mark_punct{
    pattern { e:H-[mark]->X1; H -[punct]-> P; X1 << P; P << H} % punctuation marks preceding the old head are not concerned with the head change; when there are two marks in this case, only one does not change its governor (UD_French-GSD@dev: fr-ud-dev_01506)
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 << X2 ; X2 << H}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 >> X2 ; X2 >> H}
    without{ * -[cop]-> H} % Ex : quel que soit ...
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H==>X1;
      shift_out H =[aux|aux:pass|aux:caus|cop|mark|case]=> X1;
      shift_out H =[cc|punct|root]=> X1;
    }
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package relations {
  rule comp_agent {
    pattern { e:H -[obl:agent]-> C; }
    commands { del_edge e; add_edge H -[comp:agent]-> C }
  }
  rule comp_cleft {
    pattern { e:H -[advcl:cleft]-> C; }
    commands { del_edge e; add_edge H -[comp:cleft]-> C }
  }
  rule comp_lvc {
    pattern { e:H -[obj:lvc]-> C; }
    commands { del_edge e; add_edge H -[comp:lvc]-> C }
  }
  rule comp_obj {
    pattern { e:H -[obj|obj:agent|ccomp]-> C; }
    commands { del_edge e; add_edge H -[comp:obj]-> C }
  }
  rule comp_obj_caus {
    pattern { e:H -[obj:agent]-> C; A -[comp:caus]-> H}
    commands { del_edge e; add_edge A -[comp:obj]-> C }
  }
  rule comp_obl {
    pattern { e:H -[obl:arg|iobj]-> C; }
    commands { del_edge e; add_edge H -[comp:obl]-> C }
  }
  rule comp_obl_ccomp {
    pattern { e:H -[ccomp]-> C; C[cat = ADP]; }
    commands { del_edge e; add_edge H -[comp:obl]-> C }
  }
  rule comp_rais {
    pattern { e:H -[xcomp]-> C; }
    commands { del_edge e; add_edge H -[comp:pred]-> C }
  }
  rule dep {
    pattern { e:H -[acl|acl:relcl|amod|nmod|nummod|obl]-> C; }
    commands { del_edge e; add_edge H -[dep_SUD]-> C }
  }
  rule dep_advmod {
    pattern { H[cat=NOUN|NUM|PRON|PROPN|SYM|X];  e:H -[advmod]-> C}
    commands { del_edge e; add_edge H -[dep_SUD]-> C }
  }
  rule mod {
    pattern { e:H -[advmod|advmod:neg|advcl|obl:mod]-> C; }
    without{ H[cat=NOUN|NUM|PRON|PROPN|SYM|X]}
    commands { del_edge e; add_edge H -[mod]-> C }
  }
  rule subj {
    pattern { e:H -[nsubj|nsubj:pass|csubj|csubj:pass]-> C}
    commands { del_edge e; add_edge H -[subj]-> C }
  }

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% In head changes, some dependents did not rise wrongly and it is necessary to correct it.
package gov_rise{

  rule conj_aux_rise{
    pattern{
      AUX -[comp:aux|comp:caus|comp:pred|comp:pass]-> V;
      e: V -[conj]-> V1; V1[VerbForm];
      AUX.VerbForm = V1.VerbForm
    }
    commands{del_edge e; add_edge AUX -[conj]-> V1}
  }

  rule conj_case_rise{
    pattern{
      PREP1[cat=ADP]; PREP1 -[comp]-> C;
      e: C -[conj]-> PREP2; PREP2[cat=ADP]
    }
    commands{del_edge e; add_edge PREP1 -[conj]-> PREP2}
  }

  rule conj_mark_rise{
    pattern{
      CS1[cat=SCONJ]; CS1 -[comp]-> C;
      e: C -[conj]-> CS2; CS2[cat=SCONJ]
    }
    commands{del_edge e; add_edge CS1 -[conj]-> CS2}
  }


  rule raise_dep{
    pattern {
      G -> D; D >> G; MOD[cat=ADV]; MOD << G;
      mod_rel:D -[dep_SUD]-> MOD
    }
    commands {
      del_edge mod_rel;
      add_edge G -[dep_SUD]-> MOD
    }
  }

% Modifiers preceding their governor with non projectivity rise to the governor of their governor.
  rule raise_mod{
    pattern {
      G -> D; D >> G; MOD << G;
      mod_rel:D -[mod]-> MOD
    }
    without { MOD [PronType=Rel]}
    commands {
      del_edge mod_rel;
      add_edge G -[mod]-> MOD
    }
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dependencies of type CONJ, FIXED and FLAT:NAME grouped into a bouquet are reorganized into a chain.
package chained_relations {
  rule conj {
    pattern {H -[conj]-> D1;e: H -[conj]-> D2;D1 << D2}
    without {H -[conj]-> D;D1 << D; D << D2}
    without {H -[conj]-> D;D2 << D}
    commands {del_edge e;add_edge D1 -[conj]-> D2}
  }

  rule fixed {
    pattern {H -[fixed]-> D1;e: H -[fixed]-> D2;D1 << D2}
    without {H -[fixed]-> D;D1 << D; D << D2}
    without {H -[fixed]-> D;D2 << D;}
    commands {del_edge e;add_edge D1 -[fixed]-> D2}
  }

  rule flat_name {
    pattern {H -[flat:name]-> D1;e: H -[flat:name]-> D2;D1 << D2}
    without {H -[flat:name]-> D;D1 << D; D << D2}
    without {H -[flat:name]-> D;D2 << D}
    commands {del_edge e;add_edge D1 -[flat:name]-> D2}
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package correction{
  rule mod_adv{
    pattern{ ADV[cat=ADV]; e: H -[dep_SUD]-> ADV; ADV << H}
    commands{ del_edge e; add_edge H -[mod]-> ADV}
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package fail_label{

  rule FAIL_acl{
    pattern{e: G -[acl]-> D}
    commands{del_edge e; add_edge G -[FAIL_acl]-> D}
  }

  rule FAIL_acl_relcl{
    pattern{e: G -[acl:relcl]-> D}
    commands{del_edge e; add_edge G -[FAIL_acl:relcl]-> D}
  }

  rule FAIL_advcl{
    pattern{e: G -[advcl]-> D}
    commands{del_edge e; add_edge G -[FAIL_advcl]-> D}
  }

  rule FAIL_advcl_cleft{
    pattern{e: G -[advcl:cleft]-> D}
    commands{del_edge e; add_edge G -[FAIL_advcl:cleft]-> D}
  }

  rule FAIL_advmod{
    pattern{e: G -[advmod]-> D}
    commands{del_edge e; add_edge G -[FAIL_advmod]-> D}
  }

  rule FAIL_amod{
    pattern{e: G -[amod]-> D}
    commands{del_edge e; add_edge G -[FAIL_amod]-> D}
  }

  rule FAIL_aux{
    pattern{e: G -[aux]-> D}
    commands{del_edge e; add_edge G -[FAIL_aux]-> D}
  }

  rule FAIL_aux_pass{
    pattern{e: G -[aux:pass]-> D}
    commands{del_edge e; add_edge G -[FAIL_aux:pass]-> D}
  }

  rule FAIL_aux_caus{
    pattern{e: G -[aux:caus]-> D}
    commands{del_edge e; add_edge G -[FAIL_aux:caus]-> D}
  }

  rule FAIL_case{
    pattern{e: G -[case]-> D}
    commands{del_edge e; add_edge G -[FAIL_case]-> D}
  }

  rule FAIL_ccomp{
    pattern{e: G -[ccomp]-> D}
    commands{del_edge e; add_edge G -[FAIL_ccomp]-> D}
  }

  rule FAIL_cop{
    pattern{e: G -[cop]-> D}
    commands{del_edge e; add_edge G -[FAIL_cop]-> D}
  }

  rule FAIL_csubj{
    pattern{e: G -[csubj]-> D}
    commands{del_edge e; add_edge G -[FAIL_csubj]-> D}
  }

  rule FAIL_csubj_pass{
    pattern{e: G -[csubj:pass]-> D}
    commands{del_edge e; add_edge G -[FAIL_csubj:pass]-> D}
  }

  rule FAIL_iobj{
    pattern{e: G -[iobj]-> D}
    commands{del_edge e; add_edge G -[FAIL_iobj]-> D}
  }

  rule FAIL_mark{
    pattern{e: G -[mark]-> D}
    commands{del_edge e; add_edge G -[FAIL_mark]-> D}
  }

  rule FAIL_nmod{
    pattern{e: G -[nmod]-> D}
    commands{del_edge e; add_edge G -[FAIL_nmod]-> D}
  }

  rule FAIL_nsubj{
    pattern{e: G -[nsubj]-> D}
    commands{del_edge e; add_edge G -[FAIL_nsubj]-> D}
  }

  rule FAIL_nsubj_pass{
    pattern{e: G -[nsubj:pass]-> D}
    commands{del_edge e; add_edge G -[FAIL_nsubj:pass]-> D}
  }

  rule FAIL_nummod{
    pattern{e: G -[nummod]-> D}
    commands{del_edge e; add_edge G -[FAIL_nummod]-> D}
  }

  rule FAIL_obj{
    pattern{e: G -[obj]-> D}
    commands{del_edge e; add_edge G -[FAIL_obj]-> D}
  }

  rule FAIL_obj_agent{
    pattern{e: G -[obj]-> D}
    commands{del_edge e; add_edge G -[FAIL_obj_agent]-> D}
  }

  rule FAIL_obl{
    pattern{e: G -[obl]-> D}
    commands{del_edge e; add_edge G -[FAIL_obl]-> D}
  }

  rule FAIL_obl_mod{
    pattern{e: G -[obl:mod]-> D}
    commands{del_edge e; add_edge G -[FAIL_obl:mod]-> D}
  }

  rule FAIL_obl_arg{
    pattern{e: G -[obl:arg]-> D}
    commands{del_edge e; add_edge G -[FAIL_obl:arg]-> D}
  }

  rule FAIL_obl_agent{
    pattern{e: G -[obl]-> D}
    commands{del_edge e; add_edge G -[FAIL_obl_agent]-> D}
  }

  rule FAIL_xcomp{
    pattern{e: G -[xcomp]-> D}
    commands{del_edge e; add_edge G -[FAIL_xcomp]-> D}
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
strat main {
  Seq (
    Onf (eud_to_ud),
    Onf (minimize_conj_dep),
    Onf (head_reverse),
    Onf (relations),
    Onf (gov_rise),% Package GOV_RISE must follow package HEAD_REVERSE because it corrects some wrong consequences of head changes.
    Onf (chained_relations),% Package CHAINED_RELATIONS must follow package GOV_RISE because it can entail a wrong coordination between two elements because of errors in head changes (UD_French-GS: fr-ud-dev_00131).
    Onf (fail_label),
  )
}
