%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Feature "nom" is used to deal with all nominals in a uniform way.
package nom_init {

% All words with NOUN, PRON, PROPN, SYM, X as POS are nominals.
  rule nom_noun {
    pattern {N[cat=NOUN|PRON|PROPN|SYM|X,!nom]}
    without{N[cat=SYM]; M -[mod]-> N; N << M} % Ex: + 3,6 %
    commands {N.nom=y}
  }

% All adverbs with a COMP:OBJ or SUBJ function are nominals.
  rule nom_adv {
    pattern {A[cat=ADV,!nom]; * -[comp:obj|subj]-> A}
    commands {A.nom=y}
  }
% All words with a determiner are nominals.
  rule nom_det {
    pattern {N[cat<>NOUN|PRON|PROPN|X,!nom]; N -[det]-> *}
    commands {N.nom=y}
  }

% All numerals following their gouvernor are nominals.
  rule nom_num_after {
    pattern {N[cat=NUM,!nom]; H -> N; H << N}
    commands {N.nom=y}
  }

% All numerals preceding their governor with a relation that is normally used for nominals are nominals.
  rule nom_num_before {
    pattern {N[cat=NUM,!nom]; H -[comp|comp:obj|comp:obl|mod|subj|udep]-> N; H >> N}
    commands {N.nom=y}
  }

% Question marks that are target of DEP_SUD dependencies are nominals.
  rule nom_punct {
    pattern {P[cat=PUNCT,lemma="?", !nom]; * -[dep_SUD]-> P}
    commands {P.nom=y}
  }

% When a MWE is a nominal, the node representing this expression is marked as a nominal.
  rule nom_mwe{
    pattern{H -[expr]-> N; H[!nom]; N[_MISC_MWEPOS=NOUN|PRON|PROPN|SYM|X]}
    commands{H.nom=y}
  }

% A node representing a title is marked as a nominal.
  rule nom_title{
    pattern{H -[expr]-> N; H[!nom]; N[_MISC_TITLE=Yes]}
    commands{H.nom=y}
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dependencies of type FLAT_NAME, FIXED or CONJ that are chained are reorganized into bouquets.
package unchained_relations {
  rule flat_name {
    pattern { H -[flat:name]-> D1; e: D1 -[flat:name]-> D2; }
    without { * -[flat:name]-> H; }
    commands { del_edge e; add_edge H -[flat:name]-> D2; }
  }

  rule fixed {
    pattern { H -[fixed]-> D1; e: D1 -[fixed]-> D2; }
    without { * -[fixed]-> H; }
    commands { del_edge e; add_edge H -[fixed]-> D2; }
  }

% The second conjunct has neither subject nor determiner.
  rule conj {
    pattern { H -[conj]-> D1;e: D1 -[conj]-> D2 }
    without { D1 -[det|subj]-> * }
    without { H -[conj]-> X; D1 << X; X << D2 }
    commands { del_edge e; add_edge H -[conj]-> D2 }
  }

% The second and the third conjuncts have a determiner.
  rule conj_det1 {
    pattern {
      H -[conj]-> D1;e: D1 -[conj]-> D2;
      D1 -[det]-> *; D2 -[det]-> *
    }
    without { H -[conj]-> X; D1 << X; X << D2 }
    commands {del_edge e;add_edge H -[conj]-> D2 }
  }

% The second conjunct has a determiner and the third conjunct is proper noun or a pronoun.
  rule conj_det2 {
    pattern {
      H -[conj]-> D1; e: D1 -[conj]-> D2;
      D1 -[det]-> *; D2[cat=PROPN|PRON]
    }
    without { H -[conj]-> X; D1 << X; X << D2 }
    commands { del_edge e; add_edge H -[conj]-> D2 }
  }

% The second and the third conjuncts have a subject.
  rule conj_subj {
    pattern {
      H -[conj]-> D1;e: D1 -[conj]-> D2;
      D1 -[subj]-> *; D2 -[subj]-> *
    }
    commands {del_edge e;add_edge H -[conj]-> D2 }
  }
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The COMP relations from adpositions,subordination conjunctions and some particles are reversed.
package reverse_case_mark {
% A preposition governs a nominal.
  rule case_nom {
    pattern { e:H -[comp]-> D; H [cat=ADP|SYM]; D[nom=y] }
    without { D -[comp]-> * }
    commands {
      del_edge e;
      shift_in H ==> D;
      shift_out H =[^expr|fixed|conj:dicto|reparandum]=> D;
      add_edge D -[case]-> H;
    }
  }

% An adposition governs an adverb or an adjective that is not the head of a clause.
  rule case_adv-adj {
    pattern { e:H -[comp]-> D; H [cat=ADP]; D[cat=ADV|ADJ] }
    without { D -[comp]-> * }
    without { D -[mark]-> * }
    commands {
      del_edge e;
      shift_in H ==> D;
      shift_out H =[^expr|fixed|conj:dicto|reparandum]=> D;
      add_edge D -[case]-> H;
    }
  }

% A conjunction governs a nominal that is not the head of a clause. It is considered as an adposition.
  rule case_conj {
    pattern { e:H -[comp]-> D; H [cat=CCONJ|SCONJ]; D[nom=y] }
    without { D -[comp]-> * }
    without{ D -[mark]-> *}
    commands {
      del_edge e;
      shift_in H ==> D;
      shift_out H =[^expr|fixed|conj:dicto|reparandum]=> D;
      add_edge D -[case]-> H;
    }
  }

% An adposition governs a verb that is a not a nominal.
  rule mark_adp_verb {
    pattern { e:H -[comp]-> D; H [cat=ADP]; D[cat=VERB|AUX,!nom] }
    without { D -[comp]-> * }
    commands {
      del_edge e;
      shift_in H ==> D;
      shift_out H =[^aux|aux:pass|expr|fixed|conj:dicto|reparandum]=> D;
      add_edge D -[mark]-> H;
    }
  }

% An adposition governs the head of clause.
  rule mark_adp_clause {
    pattern { e:H -[comp]-> D; H [cat=ADP]; D -[mark]-> * }
    without { D -[comp]-> * }
    commands {
      del_edge e;
      shift_in H ==> D;
      shift_out H =[^aux|aux:pass|expr|fixed|conj:dicto|reparandum]=> D;
      add_edge D -[mark]-> H;
    }
  }

% A conjunction governs a verb, an adverb or an adjective that is a not a nominal.
  rule mark_conj {
    pattern { e:H -[comp]-> D; H[cat=CCONJ|SCONJ]; D[cat=VERB|AUX|ADJ|ADV|INTJ,!nom] }
    without { D -[comp]-> * }
    commands {
      del_edge e;
      shift_in H ==> D;
      shift_out H =[^expr|fixed|discourse|reparandum]=> D;
      add_edge D -[mark]-> H;
    }
  }

% A conjunction governs an adpositional phrase.
  rule mark_conj_adp {
    pattern {e:H -[comp]-> D; H [cat=CCONJ|SCONJ]; D -[case]-> *}
    without { D -[comp]-> * }
    commands {
      del_edge e;
      shift_in H ==> D;
      shift_out H =[^expr|fixed|discourse|reparandum]=> D;
      add_edge D -[mark]-> H;
    }
  }

}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The relations from tense, passive and causative auxiliaries to the main verb are reversed.
package reverse_aux {
% Tense auxiliaries.
  rule aux {
    pattern { e:V -[comp:aux]-> C }
    without { * -[comp:aux|comp:pass]-> V }
    commands {
      del_edge e;
      shift_in V ==> C;
      shift_out V =[^fixed|conj:dicto|orphan|reparandum]=> C;
      add_edge C -[aux]-> V;
    }
  }

% Passive auxiliaries.
  rule pass {
    pattern { e:V -[comp:pass]-> C }
    without { * -[comp:aux|comp:pass]-> V }
    commands {
      del_edge e;
      shift_in V ==> C;
      shift_out V =[^fixed|conj:dicto|orphan|reparandum]=> C;
      add_edge C -[aux:pass]-> V;
    }
  }

% Causative auxiliaries without object that is the agent of the caused verb.
  rule caus {
    pattern { e:V -[comp:caus]-> C }
    without { * -[comp:aux|comp:pass]-> V }
    without { V -[comp:obj]-> * }
    commands {
      del_edge e;
      shift_in V ==> C;
      shift_out V =[^fixed|conj:dicto|orphan|reparandum]=> C;
      add_edge C -[aux:caus]-> V;
    }
  }

% Causative auxiliaries with an object that is the agent of the caused verb.
  rule caus_obj_agent {
    pattern { e:V -[comp:caus]-> C; obj: V -[comp:obj]-> O; }
    without { * -[comp:aux|comp:pass]-> V }
    commands {
      del_edge e;
      del_edge obj;
      shift_in V ==> C;
      shift_out V =[^fixed|conj:dicto|orphan|reparandum]=> C;
      add_edge C -[aux:caus]-> V;
      add_edge C -[obj:agent]-> O;
    }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Re-labelling of SUBJ relations.
package subj {
% The subject is nominal and there is no passive or causative auxiliary.
  rule nsubj {
    pattern { e:V -[subj]-> S; S[nom=y] }
    without { V -[aux:pass|aux:caus]-> * }
    commands { del_edge e; add_edge V -[nsubj]-> S }
  }

% The subject is nominal and there is a caus auxiliary.
  rule nsubj_caus {
    pattern {  e:V -[subj]-> S; S[nom=y];  V -[aux:caus]-> * }
    commands { del_edge e; add_edge V -[nsubj:caus]-> S }
  }

% The subject is nominal and there is a passive auxiliary.
  rule nsubj_pass {
    pattern {  e:V -[subj]-> S; S[nom=y];  V -[aux:pass]-> * }
    commands { del_edge e; add_edge V -[nsubj:pass]-> S }
  }

% The subject is clausal and there is no passive auxiliary.
  rule csubj {
    pattern { e:V -[subj]-> S; S[cat=AUX|VERB, !nom] }
    without { V -[aux:pass]-> * }
    commands { del_edge e; add_edge V -[csubj]-> S }
  }

% The subject is clausal and there is a passive auxiliary.
  rule csubj_pass {
    pattern { e:V -[subj]-> S; S[cat=AUX|VERB];  V -[aux:pass]-> * }
    commands { del_edge e; add_edge V -[csubj:pass]-> S }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Some determiner relations are re-labelled.
package det{
% When a determiner relation has a numeral as its dependent, it is labelled with NUMMOD.
  rule det_nummod{
    pattern { e: H -[det]-> D; D[cat=NUM] }
    commands { del_edge e; add_edge H -[nummod]-> D }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Relations COMP for required complements are re-labelled.
package comp {
  rule advclcleft {
    pattern { e:H -[comp:cleft]-> D }
    commands { del_edge e; add_edge H -[advcl:cleft]-> D }
  }

  rule ccomp {
    pattern {
      e:H -[comp:obj|comp:obl]-> D; D[cat = ADJ|AUX|VERB,!nom];
    }
    commands { del_edge e; add_edge H -[ccomp]-> D }
  }

  rule ccomp_mark {
    pattern {
      e:H -[comp:obj|comp:obl]-> D; D -[mark]-> *
    }
    commands { del_edge e; add_edge H -[ccomp]-> D }
  }
  
  rule iobj {
    pattern { e:H -[comp:obl]-> D; D[cat=PRON]}
    without { D -[case]-> * }
    commands { del_edge e; add_edge H -[iobj]-> D }
  }

  rule iobj_agent {
    pattern { e:H -[comp:agent]-> D}
    without{ D -[case]-> *}
    commands { del_edge e; add_edge H -[iobj:agent]-> D }
  }
  
  rule obj {
    pattern { e:H -[comp:obj]-> D; D[nom=y];  }
    without { D -[cop]-> C; }
    commands { del_edge e; add_edge H -[obj]-> D }
  }

  rule obj_lvc {
    pattern {e:H -[comp:lvc]-> D;  }
    commands { del_edge e; add_edge H -[obj:lvc]-> D }
  }

  rule obl_arg_adv {
    pattern { e:H -[comp:obl]-> D; D[cat=ADV] }
    without { D -[case]-> *}
    commands { del_edge e; add_edge H -[obl:arg]-> D }
  }
  
  rule obl_arg_case {
    pattern {e:H -[comp:obl]-> D; D -[case]-> * }
    without {D -[mark]-> *}
    commands { del_edge e; add_edge H -[obl:arg]-> D }
  }

  rule obl_arg_nom {
    pattern { e:H -[comp:obl]-> D; D[cat <> PRON,nom=y] }
    without { D -[case]-> *}
    commands { del_edge e; add_edge H -[obl:arg]-> D }
  }

  rule xcomp {
    pattern { e:H -[comp:pred]-> D; H [cat <> AUX|PART] }
    commands { del_edge e; add_edge H -[xcomp]-> D }
  }

  rule obl_agent {
    pattern { e:H -[comp:agent]-> D; D -[case]-> * }
    commands { del_edge e; add_edge H -[obl:agent]-> D }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Relations MOD are re-labelled.
package mod {
% A nominal governs a participle in a MOD relation.
  rule acl {
    pattern {
      e:H -[mod]-> D; H[nom=y];
      D[cat=AUX|VERB,!nom]
    }
    commands { del_edge e; add_edge H -[acl]-> D }
  }

%  A nominal governs a finite verb in a MOD relation and the hypothesis is that this verb is always the head of a relative clause.
  rule aclrel {
    pattern {
      e:H -[mod]-> D;
     % H[nom=y]; H can be an adverb
      D[cat=AUX|VERB,VerbForm=Fin]  }
    without { D -[mark]-> *}
    commands { del_edge e; add_edge H -[acl:relcl]-> D }
  }

%  A nominal governs a verb with a finite auxiliary in a UDEP relation and the hypothesis is that this verb is always the head of a relative clause.
  rule aclrel_aux {
    pattern {
      e:H -[mod]-> D;
      %H[nom=y];
      D -[aux|aux:pass|aux:caus]-> AUX; AUX[VerbForm=Fin]  }
    without { D -[mark]-> *}
    commands { del_edge e; add_edge H -[acl:relcl]-> D }
  }

% The head of a relative clause, when it is identified as the governor of a relative pronoun, is a not finite verb or auxiliary.
  rule aclrel_spec{
    pattern{
      %H[nom];
      e: H -[mod]-> D;
      D -> PRO; H << PRO; PRO[PronType=Rel]
    }
    without{D[cat=AUX|VERB,VerbForm=Fin]}
    commands{del_edge e; add_edge H -[acl:relcl]-> D}
  }

  rule advcl {
    pattern { H[!nom]; e:H -[mod]-> D; D[cat=ADJ|AUX|VERB,!nom] }
    without{H[cat=ADJ];D[cat=ADJ]}
    without {D[cat=ADJ]; D -[case]-> *}
    without{ PRO[PronType=Rel]; D -> PRO; H << PRO} % The dependency MOD is not the dependency of a relative clause.
    commands { del_edge e; add_edge H -[advcl]-> D }
  }

% Ex: fr-ud-train_01058 - Son équipe en difficulté, il est remplacé à la mi-temps ...
% Ex: fr-ud-dev_00890 - ... les restes du château d'Eaucourt étaient plus considérables qu'aujourd'hui.
% Ex: fr-ud-test_00158 - Comme chaque soir à 18h40, il tranche, malmène et détourne l'actualité.
  rule advcl_ellipsis {
    pattern {H[!nom]; e:H -[mod]-> D; D -[mark|nsubj]-> * }
    without{D[cat=VERB]}
    commands { del_edge e; add_edge H -[advcl]-> D }
  }

  rule advmod {
    pattern { e:H -[mod]-> D; D[cat=ADV|CCONJ|INTJ|PART|SYM, !nom] }
    without{D -[mark]-> *}
    commands { del_edge e; add_edge H -[advmod]-> D }
  }

  rule amod1 {
    pattern { H[cat=ADJ]; e:H -[mod]-> D; D[cat=ADJ] }
    without{ D -[mark]-> *}
    without{ PRO[PronType=Rel]; D -> PRO; H << PRO}
    commands { del_edge e; add_edge H -[amod]-> D }
  }

  rule amod2 {
    pattern { H[nom=y]; e:H -[mod]-> D; D[cat=ADJ] }
    without{ D -[mark]-> *}
    without{ PRO[PronType=Rel]; D -> PRO; H << PRO}
    commands { del_edge e; add_edge H -[amod]-> D }
  }

  rule nmod {
    pattern {e:H -[mod]-> D; H[nom=y]; D[nom=y]}
    without{D -[mark]-> *}
    without{ PRO[PronType =Rel]; D -> PRO; H << PRO; PRO << D} % D cannot be the head of relative clause, H being the antecedent of this clause.
    commands { del_edge e; add_edge H -[nmod]-> D }
  }

  rule nmod_num {
    pattern {e:H -[mod]-> D; H[cat=NUM]; D[cat=NUM]}
    commands { del_edge e; add_edge H -[nmod]-> D }
  }
  rule nummod {
    pattern { e:H -[mod]-> D; D[cat=NUM]; H[nom=y]; D << H }
    without{ PRO[PronType=Rel]; D -> PRO; H << PRO}
    commands { del_edge e; add_edge H -[nummod]-> D }
  }

  rule oblmod {
    pattern { H[!nom]; e:H -[mod]-> D; D[nom=y] }
    without{ D -[nsubj|mark]-> *}
    without{H[cat=NUM];D[cat=NUM]}
    commands { del_edge e; add_edge H -[obl:mod]-> D }
  }

  rule oblmod_adj {
    pattern { H[!nom]; e:H -[mod]-> D; D[cat=ADJ,!nom]; D -[case]-> * }
    commands { del_edge e; add_edge H -[obl:mod]-> D }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Relations UDEP are re-labelled. At this stage, some auxilairies are still heads of clauses.
% A nominal governs an infinitive or a participle in a UDEP relation.
package udep {
  rule acl_non-finite-clause {
    pattern {
      e:H -[udep]-> D; H[nom=y];
      D[cat=AUX|VERB,!nom]
    }
    commands { del_edge e; add_edge H -[acl]-> D }
  }

%  A nominal governs the head of a complementized clause in a UDEP relation.
  rule acl_mark-clause {
    pattern {
      e:H -[udep]-> D; H[nom=y];
      D -[mark]-> *
    }
    commands { del_edge e; add_edge H -[acl]-> D }
  }


% A nominal governs a nominal in a DEP_SUD relation.
  rule nmod {
    pattern {e:H -[udep]-> D; H[nom=y]; D[nom=y]}
    without{D -[mark]-> *}
    without{ PRO[PronType =Rel]; D -> PRO; H << PRO; PRO << D} % D cannot be the head of relative clause, H being the antecedent of this clause.
    commands { del_edge e; add_edge H -[nmod]-> D }
  }

% A nominal governs an adjective introduced with an adpostion in a DEP_SUD relation.
  rule nmod_adj {
    pattern {e:H -[udep]-> D; H[nom=y]; D[cat=ADJ]; D -[case]-> *}
    without{D -[mark]-> *}
    commands { del_edge e; add_edge H -[nmod]-> D }
  }

% A numeral is dependent on another numeral via an adposition.
  rule nmod_num{
    pattern {
      N1[cat=NUM]; N2[cat=NUM]; e:N1 -[udep]-> N2;
      N2 -[case]-> P
    }
    commands{del_edge e; add_edge N1 -[nmod]-> N2}
  }


% A predicate governs a nominal or an adjective in a DEP_SUD relation.
  rule obl {
    pattern {e:H -[udep]-> D; H[cat=ADJ|ADV|VERB|AUX|INTJ,!nom]}
    without{D[cat <> ADJ|ADV, !nom]}
    commands { del_edge e; add_edge H -[obl]-> D }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The relations from copulas to the predicate they govern are reversed
package reverse_cop {
  rule cop {
    pattern { V[cat=AUX|PART]; e:V -[comp:pred]-> C }
    commands {
      del_edge e;
      shift_in V ==> C;
      shift_out V =[^fixed|conj:dicto|orphan|reparandum]=> C;
      add_edge C -[cop]-> V;
    }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package final {
  rule del_nom{
    pattern {W[nom=y]}
    commands {del_feat W.nom}
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
strat main {
  Seq (
    Onf (nom_init),
    Onf (unchained_relations), % For CONJ relations, chains must be transformed into bouquets before head changes because of conditions on the presence of prepositions, conjunctions and auxiliaries. It is easier to take these conditions into account before head changes (UD_French-GSD : fr-ud-dev_00751)
    Onf (reverse_case_mark), % Package REVERSE_CASE_MARK precedes package COMP because  UD labels of complement relations depend on the category of the complements introduced with a preposition or a conjunction
    Onf (reverse_aux), % Package REVERSE_AUX precedes package SUBJ because of the simultaneous presence of a tense auxiliary and a passive auxiliary. The order between them is cancelled in this way.
    Onf (subj),
    Onf (det),
    Onf (comp),
    Onf (mod),
    Onf (udep),% Regarding the detection of relative clauses, it would be preferable to put package DEP_SUD before package REVERSE_AUX, because relative clauses are detected as finite clauses.
    Onf (reverse_cop), % Package REVERSE_COP follows packages COMP, MOD and DEP_SUD because UD labels of complement relations are different depending on whether the gouvernor or the dependent is a predicative head or a noun. It also follows package SUBJ because the copula must be the head of its clause in order to distinguish CSUBJ from NSUBJ.
    Onf (final),
  )
}
