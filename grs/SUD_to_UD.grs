%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Feature "nom" is used to deal with all nominals in a uniform way.
package nom_init {

  rule nom_noun {
    pattern {N[cat=NOUN|PRON|PROPN|SYM|X,!nom]}
    without {N[MWEPOS <> NOUN]}
    commands {N.nom=y}
  }

  rule nom_det {
    pattern {N[cat<>NOUN|PRON|PROPN|SYM|X,!nom]; N -[det]-> *}
    commands {N.nom=y}
  }

  rule nom_num1 {
    pattern {N[cat=NUM,!nom]; H -> N; H << N}
    commands {N.nom=y}
  }

  rule nom_num2 {
    pattern {N[cat=NUM,!nom]; H -[comp:obj|comp:obl|mod|obl:mod|subj]-> N; H >> N}
    commands {N.nom=y}
  }

  rule nom_punct {
    pattern {P[cat=PUNCT,lemma="?", !nom]; * -[dep_SUD]-> P}
    commands {P.nom=y}
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dependencies of type FLAT_NAME, FIXED or CONJ that are chained are reorganized into bouquets.
package unchained_relations {
  rule flat_name {
    pattern { H -[flat:name]-> D1; e: D1 -[flat:name]-> D2; }
    without { * -[flat:name]-> H; }
    commands { del_edge e; add_edge H -[flat:name]-> D2; }
  }

  rule fixed {
    pattern { H -[fixed]-> D1; e: D1 -[fixed]-> D2; }
    without { * -[fixed]-> H; }
    commands { del_edge e; add_edge H -[fixed]-> D2; }
  }

% The second conjunct has neither subject nor determiner.
  rule conj {
    pattern { H -[conj]-> D1;e: D1 -[conj]-> D2 }
    without { D1 -[det|subj]-> * }
    without { H -[conj]-> X; D1 << X; X << D2 }
    commands { del_edge e; add_edge H -[conj]-> D2 }
  }

% The second and the third conjuncts have a determiner.
  rule conj_det1 {
    pattern {
      H -[conj]-> D1;e: D1 -[conj]-> D2;
      D1 -[det]-> *; D2 -[det]-> *
    }
    without { H -[conj]-> X; D1 << X; X << D2 }
    commands {del_edge e;add_edge H -[conj]-> D2 }
  }

% The second conjunct has a determiner and the third conjunct is proper noun or a pronoun.
  rule conj_det2 {
    pattern {
      H -[conj]-> D1; e: D1 -[conj]-> D2;
      D1 -[det]-> *; D2[cat=PROPN|PRON]
    }
    without { H -[conj]-> X; D1 << X; X << D2 }
    commands { del_edge e; add_edge H -[conj]-> D2 }
  }

% The second and the third conjuncts have a subject.
  rule conj_subj {
    pattern {
      H -[conj]-> D1;e: D1 -[conj]-> D2;
      D1 -[subj]-> *; D2 -[subj]-> *
    }
    commands {del_edge e;add_edge H -[conj]-> D2 }
  }
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package reverse_case_mark {

  rule case {
    pattern { e:P -[comp]-> C; P [cat=ADP|PART|SCONJ]; C[cat<>VERB|AUX] }
    without { C -[comp]-> * }
    without { P -> D; P << D; D << C}
    commands {
      del_edge e;
      shift_in P ==> C;
      shift_out P =[^fixed|conj:dicto]=> C;
      add_edge C -[case]-> P;
    }
  }

  rule case_mod {
    pattern {
      e:P -[comp]-> C; P [cat=ADP|PART|SCONJ]; C[cat<>VERB|AUX];
      P -> D; P << D; D << C
    }
    without { C -[comp]-> * }
    commands {
      del_edge e;
      shift_in P ==> C;
      shift_out P =[^fixed|conj:dicto]=> C;
      add_edge C -[case]-> P;
    }
  }

  rule case_verb {
    pattern { e:P -[comp]-> C; P [cat=ADP|PART]; C[cat=VERB|AUX,nom=y] }
    without { P -> D; P << D; D << C}
    commands {
      del_edge e;
      shift_in P ==> C;
      shift_out P =[^fixed|conj:dicto]=> C;
      add_edge C -[case]-> P;
    }
  }

  rule case_verb_mod {
    pattern {
      e:P -[comp]-> C; P [cat=ADP|PART]; C[cat=VERB|AUX,nom=y];
      P -> D; P << D; D << C
    }
    commands {
      del_edge e;
      shift_in P ==> C;
      shift_out P =[^fixed|conj:dicto]=> C;
      add_edge C -[case]-> P;
    }
  }

  rule mark_adp {
    pattern { e:P -[comp]-> C; P [cat=ADP|PART]; C[cat=VERB|AUX,!nom] }
    without { P -> D; P << D; D << C}
    commands {
      del_edge e;
      shift_in P ==> C;
      shift_out P =[^aux|aux:pass|fixed|conj:dicto]=> C;
      add_edge C -[mark]-> P;
    }
  }

  rule mark_adp_mod {
    pattern {
      e:P -[comp]-> C; P [cat=ADP|PART]; C[cat=VERB|AUX,!nom];
      P -> D; P << D; D << C
    }
    commands {
      del_edge e;
      shift_in P ==> C;
      shift_out P =[^fixed|conj:dicto]=> C;
      add_edge C -[mark]-> P;
    }
  }

  rule mark_conj {
    pattern { e:P -[comp]-> C; P [cat=CCONJ|SCONJ]; C[cat=VERB|AUX,!nom] }
    without { C -[comp]-> * }
    without { P -> D; P << D; D << C}
    commands {
      del_edge e;
      shift_in P ==> C;
      shift_out P =[^fixed|discourse]=> C;
      add_edge C -[mark]-> P;
    }
  }

  rule mark_conj_mod {
    pattern {
      e:P -[comp]-> C; P [cat=CCONJ|SCONJ]; C[cat=VERB|AUX,!nom];
      P -> D; P << D; D << C
    }
    without { C -[comp]-> * }
    commands {
      del_edge e;
      shift_in P ==> C;
      shift_out P =[^fixed|discourse]=> C;
      add_edge C -[mark]-> P;
    }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package subj {
  rule nsubj {
    pattern { e:V -[subj]-> S; S[nom=y] }
    without { V -[comp:pass]-> * }
    without { V -[comp:aux]-> V1; V1 -[comp:pass]-> * }
    commands { del_edge e; add_edge V -[nsubj]-> S }
  }

  rule nsubj_pass1 {
    pattern {  e:V -[subj]-> S; S[nom=y];  V -[comp:pass]-> * }
    commands { del_edge e; add_edge V -[nsubj:pass]-> S }
  }

  rule nsubj_pass2 {
    pattern {
      e:V -[subj]-> S; S[nom=y];
      V -[comp:aux]-> V1; V1 -[comp:pass]-> *
    }
    commands { del_edge e; add_edge V -[nsubj:pass]-> S }
  }

  rule csubj {
    pattern { e:V -[subj]-> S; S[cat=VERB|AUX, !nom] }
    without { V -[comp:pass]-> * }
    without { V -[comp:aux]-> V1; V1 -[comp:pass]-> * }
    commands { del_edge e; add_edge V -[csubj]-> S }
  }

  rule csubj_pass1 {
    pattern { e:V -[subj]-> S; S[!nom];  V -[comp:pass]-> * }
    commands { del_edge e; add_edge V -[csubj:pass]-> S }
  }

  rule csubj_pass2 {
    pattern {
      e:V -[subj]-> S; S[!nom];
      V -[comp:aux]-> V1; V1 -[comp:pass]-> * }
    commands { del_edge e; add_edge V -[csubj:pass]-> S }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
rule det_nummod{
  pattern { e: H -[det]-> N; N[cat=NUM] }
  commands { del_edge e; add_edge H -[nummod]-> N }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package comp {
  rule advclcleft {
    pattern { e:P -[comp:cleft]-> A }
    commands { del_edge e; add_edge P -[advcl:cleft]-> A }
  }

  rule ccomp {
    pattern {
      e:P -[comp:obj|comp:obl]-> A; A[cat = VERB|AUX,!nom];
    }
    commands { del_edge e; add_edge P -[ccomp]-> A }
  }

  rule iobj {
    pattern { e:P -[comp:obl]-> A; A[cat = PRON]; }
    without { A -[case]-> * }
    commands { del_edge e; add_edge P -[iobj]-> A }
  }

  rule obj {
    pattern { e:P -[comp:obj]-> A; A[nom=y];  }
    without { A -[cop]-> C; }
    commands { del_edge e; add_edge P -[obj]-> A }
  }

  rule obj_adv {
    pattern {e:P -[comp:obj]-> A; A[cat=ADV];  }
    without { A -[cop]-> C; }
    commands { del_edge e; add_edge P -[obj]-> A }
  }

  rule obj_lvc {
    pattern {e:P -[comp:lvc]-> A;  }
    commands { del_edge e; add_edge P -[obj:lvc]-> A }
  }

  rule obl_arg {
    pattern {e:P -[comp:obl]-> A; A -[case|mark]-> * }
    without { A[cat=VERB|AUX]; A -[mark]-> *}
    commands { del_edge e; add_edge P -[obl:arg]-> A }
  }

  rule obl_arg_dir {
    pattern { e:P -[comp:obl]-> A; A[cat=ADV|NOUN] }
    without { A -[case]-> *}
    commands { del_edge e; add_edge P -[obl:arg]-> A }
  }

  rule xcomp {
    pattern { e:P -[comp:rais]-> A }
    commands { del_edge e; add_edge P -[xcomp]-> A }
  }

  rule obl_agent {
    pattern { e:P -[comp:agent]-> A }
    commands { del_edge e; add_edge P -[obl:agent]-> A }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package mod {
  rule advcl {
    pattern { N[!nom]; e:N -[mod]-> M; M[cat=ADJ|VERB|AUX] }
    without { M -[case|mark]-> *}
    without { M -[det]-> *}
    commands { del_edge e; add_edge N -[advcl]-> M }
  }

  rule advcl_mark {
    pattern { N[!nom]; e:N -[mod]-> M; M[cat=ADJ|VERB|AUX] ; M -[mark]-> * }
    without { M -[det]-> *}
    commands { del_edge e; add_edge N -[advcl]-> M }
  }

  rule advmod {
    pattern { e:N -[mod]-> M; M[cat=ADV|PART] }
    without { M[nom]}
    commands { del_edge e; add_edge N -[advmod]-> M }
  }
  rule advmod_adj {
    pattern { N[!nom]; e:N -[mod]-> M; M[cat=ADJ]; M -[case]-> * }
    commands { del_edge e; add_edge N -[advmod]-> M }
  }

  rule oblmod {
    pattern { N[!nom]; e:N -[mod]-> M; M[nom=y] }
    commands { del_edge e; add_edge N -[obl:mod]-> M }
  }

  rule oblmod_det {
    pattern { N[!nom]; e:N -[mod]-> M; M[cat=VERB|AUX]; M -[det]-> * }
    commands { del_edge e; add_edge N -[obl:mod]-> M }
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package dep_SUD {
  rule acl1 {
    pattern {
      e:N -[dep_SUD]-> M; N[nom=y];
      M[cat=VERB|AUX,!nom,VerbForm=Part|Inf]
    }
    commands { del_edge e; add_edge N -[acl]-> M }
  }

  rule acl2 {
    pattern {
      e:N -[dep_SUD]-> M; N[nom=y];
      M[cat=VERB|AUX,VerbForm=Fin];
      M -[mark]-> *
    }
    commands { del_edge e; add_edge N -[acl]-> M }
  }

  rule aclrel {
    pattern { e:N -[dep_SUD]-> M; N[nom=y]; M[cat=VERB|AUX,VerbForm=Fin]  }
    without { M -[mark]-> *}
    commands { del_edge e; add_edge N -[acl:relcl]-> M }
  }

  rule advmod{
    pattern { e:H -[dep_SUD]-> D; D[cat=ADV]}
    commands { del_edge e; add_edge H -[advmod]-> D }
  }

  rule amod {
    pattern { e:H -[dep_SUD]-> D; D[cat=ADJ] }
    commands { del_edge e; add_edge H -[amod]-> D }
  }

  rule nummod {
    pattern { e:N -[dep_SUD]-> M; M[cat=NUM]}
    commands { del_edge e; add_edge N -[nummod]-> M }
  }

  rule nmod {
    pattern {e:N -[dep_SUD]-> M; N[nom=y]; M[nom=y]}
    commands { del_edge e; add_edge N -[nmod]-> M }
  }

  rule obl {
    pattern {e:M -[dep_SUD]-> N; M[cat=ADJ|ADV|VERB|AUX,!nom]}
    commands { del_edge e; add_edge M -[obl]-> N }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package reverse_aux_cop {
  rule aux {
    pattern { e:V -[comp:aux]-> C }
    without { * -[comp:aux|comp:pass]-> V }
    commands {
      del_edge e;
      shift_in V ==> C;
      shift_out V =[^fixed|conj:dicto|reparandum]=> C;
      add_edge C -[aux]-> V;
    }
  }

  rule pass {
    pattern { e:V -[comp:pass]-> C }
    without { * -[comp:aux|comp:pass]-> V }
    commands {
      del_edge e;
      shift_in V ==> C;
      shift_out V =[^fixed|conj:dicto|reparandum]=> C;
      add_edge C -[aux:pass]-> V;
    }
  }

  rule caus {
    pattern { e:V -[comp:caus]-> C }
    without { * -[comp:aux|comp:pass]-> V }
    without { V -[obj]-> * }
    commands {
      del_edge e;
      shift_in V ==> C;
      shift_out V =[^fixed|conj:dicto|reparandum]=> C;
      add_edge C -[aux:caus]-> V;
    }
  }

  rule caus_obj_agent {
    pattern { e:V -[comp:caus]-> C; obj: V -[obj]-> O; }
    without { * -[comp:aux|comp:pass]-> V }
    commands {
      del_edge e;
      del_edge obj;
      shift_in V ==> C;
      shift_out V =[^fixed|conj:dicto|reparandum]=> C;
      add_edge C -[aux:caus]-> V;
      add_edge C -[obj:agent]-> O;
    }
  }

  rule cop {
    pattern { e:V -[comp:cop]-> C }
    without { * -[comp]-> V }
    without {V -[mark]-> CS; C << CS; CS << V}
    commands {
      del_edge e;
      shift_in V ==> C;
      shift_out V =[^fixed|conj:dicto|reparandum]=> C;
      add_edge C -[cop]-> V;
    }
  }

  rule cop_mark {
    pattern {
      e:V -[comp:cop]-> C;
      V -[mark]-> CS; C << CS; CS << V
    }
    without { * -[comp]-> V } % apply cop later
    commands {
      del_edge e;
      shift_in V ==> C;
      shift_out V =[^fixed|conj:dicto|reparandum]=> C;
      add_edge C -[cop]-> V;
    }
  }
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package final {
  rule del_nom{
    pattern {W[nom=y]}
    commands {del_feat W.nom}
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
strat main {
  Seq (
    Onf (nom_init),
    Onf (unchained_relations), % For CONJ relations, chains must be transformed into bouquets before head changes because of conditions on the presence of prepositions, conjunctions and auxiliaries. It is easier to take these conditions into account before head changes (UD_French-GSD : fr-ud-dev_00751)
    Onf (reverse_case_mark), % Package REVERSE_CASE_MARK precedes package COMP because  UD labels of complement relations depend on the category of the complements introduced with a preposition or a conjunction
    Onf (subj),
    Onf (det_nummod),
    Onf (comp),
    Onf (mod),
    Onf (dep_SUD),
    Onf (reverse_aux_cop), % Package REVERSE_AUX_COP follows package DEP_SUD because UD labels of complement relations are different depending on whether the gouvernor is predicative head or a noun.
    Onf (final),
  )
}
