%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package init {
  rule mwepos {
    pattern { N [cat, mwepos, !init_cat]}
    commands { N.init_cat=N.cat; N.cat = N.mwepos; }
  }

  rule seq {
    pattern { N [cat, _MISC_MWEPOS, !init_cat]}
    commands { N.init_cat=N.cat; N.cat = N._MISC_MWEPOS; }
  }

  rule date {
    pattern { N [cat=NUM, !save_cat]; M -> N; M[lemma=en]; }
    commands { N.save_cat=N.cat; N.cat = NOUN; }
  }
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package unchained_relations {
  rule flat_name {
    pattern {
      H -[flat:name]-> N1;
      e: N1 -[flat:name]-> N2;
    }
    without {
      * -[flat:name]-> H;
    }
    commands {
      del_edge e;
      add_edge H -[flat:name]-> N2;
    }
  }

  rule fixed {
    pattern {
      H -[fixed]-> N1;
      e: N1 -[fixed]-> N2;
    }
    without {
      * -[fixed]-> H;
    }
    commands {
      del_edge e;
      add_edge H -[fixed]-> N2;
    }
  }
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package subj {
  rule nsubj {
    pattern { e:N -[subj]-> M; M[cat <> VERB] }
    without { N -[aux:pass]-> * }
    commands { del_edge e; add_edge N -[nsubj]-> M }
  }

  rule nsubj_pass {
    pattern { e:N -[subj]-> M; M[cat <> VERB];  N -[aux:pass]-> * }
    commands { del_edge e; add_edge N -[nsubj:pass]-> M }
  }

  rule csubj {
    pattern { e:N -[subj]-> M; M[cat = VERB] }
    commands { del_edge e; add_edge N -[csubj]-> M }
  }

  rule csubj_pass {
    pattern { e:N -[subj]-> M; M[cat = VERB];  N -[aux:pass]-> * }
    commands { del_edge e; add_edge N -[csubj:pass]-> M }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package comp {
  rule ccomp {
    pattern { e:N -[comp:obj|comp:obl]-> M; M[cat = VERB];  }
    commands { del_edge e; add_edge N -[ccomp]-> M }
  }

  rule ccomp_cop {
    pattern { e:N -[comp:obj|comp:obl]-> M; M -[cop]-> C;  }
    commands { del_edge e; add_edge N -[ccomp]-> M }
  }

  rule iobj {
    pattern { e:N -[comp:obl]-> M; M[cat <> VERB]; }
    without { M -[case]-> * }
    commands { del_edge e; add_edge N -[iobj]-> M }
  }

  rule obj {
    pattern { e:N -[comp:obj]-> M; M[cat <> VERB];  }
    without { M -[cop]-> C; }
    commands { del_edge e; add_edge N -[obj]-> M }
  }

  rule obj_lvc {
    pattern { e:N -[comp:lvc]-> M;  }
    commands { del_edge e; add_edge N -[obj:lvc]-> M }
  }

  rule obl_arg {
    pattern { e:N -[comp:obl]-> M; M -[case]-> * }
    commands { del_edge e; add_edge N -[obl:arg]-> M }
  }

  rule xcomp {
    pattern { e:N -[comp:rais]-> M }
    commands { del_edge e; add_edge N -[xcomp]-> M }
  }

  rule obl_agent {
    pattern { e:N -[comp:agent]-> M }
    commands { del_edge e; add_edge N -[obl:agent]-> M }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package mod {
  rule amod {
    pattern { e:N -[mod]-> M; N[cat<>VERB]; M[cat=ADJ] }
    commands { del_edge e; add_edge N -[amod]-> M }
  }

  % rule advmod_adj {
  %   pattern { e:N -[mod]-> M; N[cat=VERB]; M[cat=ADJ] }
  %   without { M -[cop]-> *}
  %   commands { del_edge e; add_edge N -[advmod]-> M }
  % }

  rule nummod {
    pattern { N[cat=NOUN|PRON|SYM]; e:N -[det|mod]-> M; M[cat=NUM] }
    commands { del_edge e; add_edge N -[nummod]-> M }
  }

%TODO --> cop GSD-train-2019
  rule acl {
    pattern { e:N -[mod]-> M; N[cat <> ADJ|VERB]; M[cat=VERB] }
    without {M -> PROREL; PROREL[PronType=Rel] }
    commands { del_edge e; add_edge N -[acl]-> M }
  }

  rule aclrel {
    pattern { e:N -[mod]-> M; N[cat <> ADJ|VERB]; M -> PROREL; PROREL[PronType=Rel] }
    commands { del_edge e; add_edge N -[acl:relcl]-> M }
  }
  rule advcl {
    pattern { e:N -[mod]-> M; N [cat = ADJ|VERB]; M[cat=ADJ|VERB] }
    commands { del_edge e; add_edge N -[advcl]-> M }
  }

  rule obl_mod {
    pattern { e:N -[mod]-> M; N [cat=ADJ|VERB]; M[cat=NOUN|PRON|PROPN|NUM|SYM] }
    without{M[cat=PRON,lemma="où"]}
    commands { del_edge e; add_edge N -[obl:mod]-> M }
  }

  rule obl_mod_cop {
    pattern { e:N -[mod]-> M; N [cat<>ADJ|VERB]; N -[cop]-> C; M[cat=NOUN|PRON|PROPN] }
    commands { del_edge e; add_edge N -[obl:mod]-> M }
  }

  rule advmod {
    pattern { e:N -[mod]-> M; M[cat=ADV|PART|PRON] }
    without { M[cat=PRON,lemma <> "où"]}
    commands { del_edge e; add_edge N -[advmod]-> M }
  }

  rule nmod {
    pattern { e:N -[dep]-> M; N[cat=SYM|NUM|NOUN|PRON|PROPN|X]; M[cat=SYM|NUM|NOUN|PRON|PROPN|X] }
    commands { del_edge e; add_edge N -[nmod]-> M }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package dep {
  rule month {
    pattern { e:M -[dep]-> N; M [lemma="janvier"|"février"|"mars"|"avril"|"mai"|"juin"|"juillet"|"août"|"septembre"|"octobre"|"novembre"|"décembre"]}
    commands { del_edge e; add_edge M -[nmod]-> N }

  }

  rule obl { % in GSD, obl are not all subtyped
    pattern { e:M -[dep]-> N; M [lemma <> "janvier"|"février"|"mars"|"avril"|"mai"|"juin"|"juillet"|"août"|"septembre"|"octobre"|"novembre"|"décembre"] }
    commands { del_edge e; add_edge M -[obl]-> N }
  }
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package reverse {

  rule aux {
    pattern { e:V -[comp:aux]-> C }
    without { * -[comp:aux|comp:pass]-> V }
    commands {
      del_edge e;
      shift_in V ==> C;
%      shift_out V =[aux|cop|subj|mod]=> C; % TODO: shift_out
      shift_out V =[^fixed]=> C; % TODO: shift_out
      add_edge C -[aux]-> V;
      V.cat=AUX
    }
  }

  rule pass {
    pattern { e:V -[comp:pass]-> C }
    without { * -[comp:aux|comp:pass]-> V }
    commands {
      del_edge e;
      shift_in V ==> C;
%      shift_out V =[aux|cop|subj|mod]=> C; % TODO: shift_out
      shift_out V =[^fixed]=> C; % TODO: shift_out
      add_edge C -[aux:pass]-> V;
      V.cat=AUX
    }
  }

  rule caus {
    pattern { e:V -[comp:caus]-> C }
    without { * -[comp:aux|comp:pass]-> V }
    without { V -[comp:obj]-> * }
    commands {
      del_edge e;
      shift_in V ==> C;
%      shift_out V =[aux|cop|subj|mod]=> C; % TODO: shift_out
      shift_out V =[^fixed]=> C; % TODO: shift_out
      add_edge C -[aux:caus]-> V;
      V.cat=AUX
    }
  }

  rule caus_obj_agent {
    pattern { e:V -[comp:caus]-> C; obj: V -[comp:obj]-> O; }
    without { * -[comp:aux|comp:pass]-> V }
    commands {
      del_edge e;
      del_edge obj;
      shift_in V ==> C;
%      shift_out V =[aux|cop|subj|mod]=> C; % TODO: shift_out
      shift_out V =[^fixed]=> C; % TODO: shift_out
      add_edge C -[aux:caus]-> V;
      add_edge C -[obj:agent]-> O;
      V.cat=AUX
    }
  }

  rule case {
    pattern { e:P -[comp]-> C; P [cat=ADP]; C[cat<>VERB] }
    without { C -[comp]-> * }
    commands {
      del_edge e;
      shift_in P ==> C;
      shift_out P =[^fixed]=> C;  % TODO: refine shift_out
      add_edge C -[case]-> P;
    }
  }

  rule mark_adp {
    pattern { e:P -[comp]-> C; P [cat=ADP]; C[cat=VERB] }
    commands {
      del_edge e;
      shift_in P ==> C;
      shift_out P =[^fixed]=> C;  % TODO: refine shift_out
      add_edge C -[mark]-> P;
    }
  }

  rule mark_conj {
    pattern { e:P -[comp]-> C; P [cat=CCONJ|SCONJ] }
    without { C -[comp]-> * }
    commands {
      del_edge e;
      shift_in P ==> C;
      shift_out P =[^fixed|discourse]=> C;  % TODO: refine shift_out
      add_edge C -[mark]-> P;
    }
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  rule cop {
    pattern { e:V -[comp:cop]-> C }
    without { * -[comp]-> V } % apply cop later
    commands {
      del_edge e;
      shift_in V ==> C;
%      shift_out V =[aux|cop|subj|mod]=> C; % TODO: shift_out
      shift_out V =[^fixed]=> C; % TODO: shift_out
      add_edge C -[cop]-> V;
      V.cat=AUX
    }
  }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
rule conj {
  pattern {
    H -[conj]-> N1;
    e: N1 -[conj]-> N2;
  }
  without {
    * -[conj]-> H;
  }
  commands {
    del_edge e;
    add_edge H -[conj]-> N2;
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package final {
  rule mwepos {
    pattern { N [init_cat, cat]}
    commands { N.cat = N.init_cat; del_feat N.init_cat; }
  }

  rule date {
    pattern { N [save_cat]; }
    commands { N.cat=N.save_cat; del_feat N.save_cat; }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
strat main {
  Seq (
    Onf (init),
    Onf (unchained_relations),
    Onf (reverse),
    Onf (subj),
    Onf (comp),
    Onf (mod),
    Onf (dep),
    Onf (cop),
    Onf (conj),
    Onf (final),
  )
}

strat full {
  Seq (
    Iter (init),
    Iter (unchained_relations),
    Iter (reverse),
    Iter (subj),
    Iter (comp),
    Iter (mod),
    Iter (dep),
    Iter (conj),
    Iter (final),
  )
}

