%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package init {

  rule MWEPOS {
    pattern { N [cat, _MISC_MWEPOS, !token_upos]}
    commands { N.token_upos=N.cat; N.cat = N._MISC_MWEPOS; }
  }

  rule UDPOS {
    pattern { N [cat, _MISC_UDPOS, !_MISC_MWEPOS, !token_upos]}
    commands { N.token_upos=N.cat; N.cat = N._MISC_UDPOS; del_feat N._MISC_UDPOS }
  }
  
  rule nom_noun{
    pattern{N[cat=NOUN|PRON|PROPN|SYM|X,!nom]}
    commands{N.nom=y}
  }
    
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package FR_init {
  rule nom_non_noun{
    pattern{N[cat<>NOUN|PRON|PROPN|SYM|X,!nom]; N -[det]-> *}
    without{N0[cat=NOUN|PRON]; N0 -[dep_SUD]-> N}% exclusion of attributive superlatives
    without{ N -[cop]-> *}% exclusion of predicative complement superlatives 
    commands{N.nom=y}
  }

  rule nom_num{
    pattern{N[cat=NUM,!nom]}
    without{H -[det|mod]-> N; N << H}
    commands{N.nom=y}
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package unchained_relations {
  rule flat_name {
    pattern {
      H -[flat:name]-> N1;
      e: N1 -[flat:name]-> N2;
    }
    without {
      * -[flat:name]-> H;
    }
    commands {
      del_edge e;
      add_edge H -[flat:name]-> N2;
    }
  }

  rule fixed {
    pattern {
      H -[fixed]-> N1;
      e: N1 -[fixed]-> N2;
    }
    without {
      * -[fixed]-> H;
    }
    commands {
      del_edge e;
      add_edge H -[fixed]-> N2;
    }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package reverse_case_mark {

  rule case {
    pattern { e:P -[comp]-> C; P [cat=ADP|PART]; C[cat<>VERB] }
    without { C -[comp]-> * }
    commands {
      del_edge e;
      shift_in P ==> C;
      shift_out P =[^fixed|conj:dicto]=> C;  % TODO: refine shift_out
      add_edge C -[case]-> P;
    }
  }

  rule case_verb {
    pattern { e:P -[comp]-> C; P [cat=ADP|PART]; C[cat=VERB,nom=y] }
    commands {
      del_edge e;
      shift_in P ==> C;
      shift_out P =[^fixed|conj:dicto]=> C;  % TODO: refine shift_out
      add_edge C -[case]-> P;
    }
  }
  rule mark_adp {
    pattern { e:P -[comp]-> C; P [cat=ADP|PART]; C[cat=VERB,!nom] }
    commands {
      del_edge e;
      shift_in P ==> C;
      shift_out P =[^fixed|conj:dicto]=> C;  % TODO: refine shift_out
      add_edge C -[mark]-> P;
    }
  }

  rule mark_conj {
    pattern { e:P -[comp]-> C; P [cat=CCONJ|SCONJ] }
    without { C -[comp]-> * }
    commands {
      del_edge e;
      shift_in P ==> C;
      shift_out P =[^fixed|discourse]=> C;  % TODO: refine shift_out
      add_edge C -[mark]-> P;
    }
  }

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package subj {
  rule nsubj {
    pattern { e:V -[subj]-> S; S[nom=y] }
    without { V -[comp:pass]-> * }
    without { V -[comp:aux]-> V1; V1 -[comp:pass]-> * }
    commands { del_edge e; add_edge V -[nsubj]-> S }
  }

  rule nsubj_pass1 {
    pattern { e:V -[subj]-> S; S[nom=y];  V -[comp:pass]-> * }
    commands { del_edge e; add_edge V -[nsubj:pass]-> S }
  }

  rule nsubj_pass2 {
    pattern {
      e:V -[subj]-> S; S[nom=y];
      V -[comp:aux]-> V1; V1 -[comp:pass]-> * }
    commands { del_edge e; add_edge V -[nsubj:pass]-> S }
  }
  rule csubj {
    pattern { e:V -[subj]-> S; S[!nom] }
    without { V -[comp:pass]-> * }
    without { V -[comp:aux]-> V1; V1 -[comp:pass]-> * }
    commands { del_edge e; add_edge V -[csubj]-> S }
  }

  rule csubj_pass1 {
    pattern { e:V -[subj]-> S; S[!nom];  V -[comp:pass]-> * }
    commands { del_edge e; add_edge V -[csubj:pass]-> S }
  }
  
  rule csubj_pass2 {
    pattern {
      e:V -[subj]-> S; S[!nom];
      V -[comp:aux]-> V1; V1 -[comp:pass]-> * }
    commands { del_edge e; add_edge V -[csubj:pass]-> S }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  rule det_nummod{
    pattern{ e: H -[det]-> N; N[cat=NUM]}
    commands{ del_edge e; add_edge H -[nummod]-> N}
  }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package comp {
  rule advclcleft {
    pattern { e:P -[comp:cleft]-> A}
    commands { del_edge e; add_edge P -[advcl:cleft]-> A }
  }

  rule ccomp {
    pattern { e:P -[comp:obj|comp:obl]-> A; A[cat = VERB,!nom];  }
    commands { del_edge e; add_edge P -[ccomp]-> A }
  }


  rule iobj {
    pattern { e:P -[comp:obl]-> A; A[cat = PRON]; }
    without { A -[case]-> * }
    commands { del_edge e; add_edge P -[iobj]-> A }
  }

  rule obj {
    pattern { e:P -[comp:obj]-> A; A[nom=y];  }
    without { A -[cop]-> C; }
    commands { del_edge e; add_edge P -[obj]-> A }
  }

  rule obj_adv {
    pattern { e:P -[comp:obj]-> A; A[cat=ADV];  }
    without { A -[cop]-> C; }
    commands { del_edge e; add_edge P -[obj]-> A }
  }

  rule obj_lvc {
    pattern { e:P -[comp:lvc]-> A;  }
    commands { del_edge e; add_edge P -[obj:lvc]-> A }
  }

  rule obl_arg {
    pattern { e:P -[comp:obl]-> A; A -[case|mark]-> * }
    without { A[cat=VERB]; A -[mark]-> *}
    commands { del_edge e; add_edge P -[obl:arg]-> A }
  }
  
  rule obl_arg_dir {
    pattern { e:P -[comp:obl]-> A; A[cat=ADV|NOUN] }
    without { A -[case]-> *}
    commands { del_edge e; add_edge P -[obl:arg]-> A }
  }

  rule xcomp {
    pattern { e:P -[comp:rais]-> A }
    commands { del_edge e; add_edge P -[xcomp]-> A }
  }

  rule obl_agent {
    pattern { e:P -[comp:agent]-> A }
    commands { del_edge e; add_edge P -[obl:agent]-> A }
  }
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package FR_mod {

  rule advmod {
    pattern { e:N -[mod]-> M; M[cat=PRON|SYM, lemma="où"|"y"|"+"] }
    commands { del_edge e; add_edge N -[advmod]-> M }
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package mod {
  rule advcl {
    pattern {N[!nom]; e:N -[mod]-> M; M[cat=ADJ|VERB] }
    without{ M -[case|mark]-> *}
    without{ M -[det]-> *}
    commands { del_edge e; add_edge N -[advcl]-> M }
  }

  rule advcl_mark {
    pattern {N[!nom]; e:N -[mod]-> M; M[cat=ADJ|VERB] ; M -[mark]-> *}
    without{ M -[det]-> *}
    commands { del_edge e; add_edge N -[advcl]-> M }
  }

  rule advmod {
    pattern { e:N -[mod]-> M; M[cat=ADV|PART] }
    without{ M -[case|mark]-> *}
    commands { del_edge e; add_edge N -[advmod]-> M }
  }

  rule oblmod {
    pattern {N[!nom]; e:N -[mod]-> M; M[cat=NOUN|NUM|PRON|PROPN|SYM] }
    commands { del_edge e; add_edge N -[obl:mod]-> M }
  }
  
  rule oblmod_case {
    pattern {N[!nom]; e:N -[mod]-> M; M[cat=ADJ|ADV]; M -[case]-> * }
    without{M -[mark]-> *}
    commands { del_edge e; add_edge N -[obl:mod]-> M }
  }
  
  rule oblmod_det {
    pattern {N[!nom]; e:N -[mod]-> M; M[cat=VERB]; M -[det]-> * }
    commands { del_edge e; add_edge N -[obl:mod]-> M }
  }

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package FR_dep_SUD {
  rule amod{
    pattern{H[cat=ADJ]; D[cat=ADJ]; e: H -[dep_SUD]-> D}
    without{D -[case|mark]-> *}
    commands{ del_edge e; add_edge H -[amod]-> D}
  }
  
  rule advmod{
    pattern{ e:H -[dep_SUD]-> D; H[nom=y]; D[cat=ADV]; H << D }
    without{D -[case]-> *}
    commands { del_edge e; add_edge H -[amod]-> D }
  }
  
  rule nmod_num {
    pattern { e:H -[dep_SUD]-> D; H[nom=y]; D[cat=NUM]; H << D }
    without{H[lemma=heure]}
    commands { del_edge e; add_edge H -[nmod]-> D }
  }
 
  rule nummod1{
    pattern { e:H -[dep_SUD]-> D; H[cat=ADJ]; D[cat=NUM]; D << H }
    without{D -[case]-> *}
    commands { del_edge e; add_edge H -[nummod]-> D }
  }

  rule nummod2{
    pattern {
      e:H -[dep_SUD]-> D; H[cat=NUM]; D[cat=NUM]; H << D;
      * -[nummod]-> H}
    commands { del_edge e; add_edge H -[nummod]-> D }
  }
  rule obl_num{
    pattern { e:H -[dep_SUD]-> D; H[cat=ADJ|ADV|VERB]; D[cat=NUM]; H << D ; D -[case]-> *}
    commands { del_edge e; add_edge H -[obl]-> D }
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package dep_SUD {
  rule acl1 {
    pattern { e:N -[dep_SUD]-> M; N[nom=y]; M[cat=VERB,VerbForm=Part|Inf] }
    commands { del_edge e; add_edge N -[acl]-> M }
  }

  rule acl2 {
    pattern {
      e:N -[dep_SUD]-> M; N[nom=y];
      M[cat=VERB,VerbForm=Fin]; M -[mark]-> *
    }
    commands { del_edge e; add_edge N -[acl]-> M }
  }

  rule aclrel {
    pattern { e:N -[dep_SUD]-> M; N[nom=y]; M[cat=VERB,VerbForm=Fin]  }
    without{ M -[mark]-> *}
    commands { del_edge e; add_edge N -[acl:relcl]-> M }
  }
  
  rule amod {
    pattern { e:N -[dep_SUD]-> M; N[nom=y]; M[cat=ADJ] }
    without{ M -[case]-> *}
    commands { del_edge e; add_edge N -[amod]-> M }
  }

  rule nummod {
    pattern { e:N -[dep_SUD]-> M; N[nom=y]; M[cat=NUM]}
    without{ M -[case]-> *}
    commands { del_edge e; add_edge N -[nummod]-> M }
  }

  rule nmod {
    pattern {e:N -[dep_SUD]-> M; N[nom=y];M[cat=SYM|NOUN|PRON|PROPN|X]
    }
    without{ M -[case]-> *}
    commands { del_edge e; add_edge N -[nmod]-> M }
  }

  rule nmod_case {
    pattern {
      e:N -[dep_SUD]-> M; N[nom=y];
      M[cat=ADJ|ADV|NOUN|NUM|PRON|PROPN|SYM|X]; M -[case]-> *
    }
    commands { del_edge e; add_edge N -[nmod]-> M }
  }

  rule obl {
    pattern {e:M -[dep_SUD]-> N; M[cat=ADJ|ADV|VERB|AUX,!nom]}
    commands { del_edge e; add_edge M -[obl]-> N }
  }

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package reverse_aux_cop {
  rule aux {
    pattern { e:V -[comp:aux]-> C }
    without { * -[comp:aux|comp:pass]-> V }
    commands {
      del_edge e;
      shift_in V ==> C;
%      shift_out V =[aux|cop|subj|mod]=> C; % TODO: shift_out
      shift_out V =[^fixed|conj:dicto]=> C; % TODO: shift_out
      add_edge C -[aux]-> V;
      V.cat=AUX
    }
  }

  rule pass {
    pattern { e:V -[comp:pass]-> C }
    without { * -[comp:aux|comp:pass]-> V }
    commands {
      del_edge e;
      shift_in V ==> C;
%      shift_out V =[aux|cop|subj|mod]=> C; % TODO: shift_out
      shift_out V =[^fixed|conj:dicto]=> C; % TODO: shift_out
      add_edge C -[aux:pass]-> V;
      V.cat=AUX
    }
  }

  rule caus {
    pattern { e:V -[comp:caus]-> C }
    without { * -[comp:aux|comp:pass]-> V }
    without { V -[obj]-> * }
    commands {
      del_edge e;
      shift_in V ==> C;
%      shift_out V =[aux|cop|subj|mod]=> C; % TODO: shift_out
      shift_out V =[^fixed|conj:dicto]=> C; % TODO: shift_out
      add_edge C -[aux:caus]-> V;
      V.cat=AUX
    }
  }

  rule caus_obj_agent {
    pattern { e:V -[comp:caus]-> C; obj: V -[obj]-> O; }
    without { * -[comp:aux|comp:pass]-> V }
    commands {
      del_edge e;
      del_edge obj;
      shift_in V ==> C;
%      shift_out V =[aux|cop|subj|mod]=> C; % TODO: shift_out
      shift_out V =[^fixed|conj:dicto]=> C; % TODO: shift_out
      add_edge C -[aux:caus]-> V;
      add_edge C -[obj:agent]-> O;
      V.cat=AUX
    }
  }
  rule cop {
    pattern { e:V -[comp:cop]-> C }
    without { * -[comp]-> V } % apply cop later
    commands {
      del_edge e;
      shift_in V ==> C;
%      shift_out V =[aux|cop|subj|mod]=> C; % TODO: shift_out
      shift_out V =[^fixed|conj:dicto]=> C; % TODO: shift_out
      add_edge C -[cop]-> V;
      V.cat=AUX
    }
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% A revoir (partage des sujets, auxiliaires, prépositions, conjonctions : fr-ud-dev_00966)
rule conj {
  pattern {
    H -[conj]-> N1;
    e: N1 -[conj]-> N2;
  }
  without {
    * -[conj]-> H;
  }
  commands {
    del_edge e;
    add_edge H -[conj]-> N2;
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package final {
  rule mwepos {
    pattern { N [token_upos, cat]}
    commands { N.cat = N.token_upos; del_feat N.token_upos; }
  }

  rule del_nom{
    pattern{W[nom=y]}
    commands{del_feat W.nom}
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
strat main {
  Seq (
    Onf (init),
    Onf (FR_init),
    Onf (unchained_relations),
    Onf (reverse_case_mark),
    Onf (subj),
    Onf (det_nummod),
    Onf (comp),
    Onf (FR_mod),
    Onf (mod),
    Onf (FR_dep_SUD),
    Onf (dep_SUD),
    Onf (reverse_aux_cop),
    Onf (conj),
    Onf (final),
  )
}


