%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
include "SUD_to_UD.grs"

strat say_main {
  Seq (
    Onf (say_pre),
    u_main,
    Onf(say_post),
    Onf(tmp_escape_aux_cop),
  )
}


package say_pre {
  rule IDEO_with_extpos {
    pattern { N[upos=IDEO, ExtPos] }
    commands { N.upos=N.ExtPos; N.Ideophon=Yes; del_feat N.ExtPos }
  }

  rule IDEO_without_extpos {
    pattern { N[upos=IDEO, !ExtPos] }
    commands { N.upos=X; N.Ideophon=Yes; }
  }

  rule raising {
    pattern { e: N -[deep=x]-> M }
    commands {
      M.Subject=Raising;
      del_feat e.deep
    }
  }
}

% TMP rule --> remove non documented extension
package say_post {
  rule parataxis {
    pattern { e: N -[1=parataxis, 2=*]-> M }
    commands { del_feat e.2 }
  }
  rule dislocated {
    pattern { e: N -[1=dislocated, 2=*]-> M }
    commands { del_feat e.2 }
  }
  rule discourse {
    pattern { e: N -[1=discourse, 2=*]-> M }
    commands { del_feat e.2 }
  }
  rule missing_extension {
    pattern { e: N -[advcl:cleft|conj:svc|compound:svc|dep:comp|flat:num|iobj:expl|iobj:agent|nmod:top|nmod:emp|obl:mod|obl:expl]-> M }
    commands { del_feat e.2 }
  }

  rule Case {
    pattern { N[Case] }
    commands { del_feat N.Case }
  }
  rule NumType {
    pattern { N[NumType] }
    commands { del_feat N.NumType }
  }
  rule Aspect_on_X {
    pattern { N[Aspect, upos=X] }
    commands { del_feat N.Aspect }
  }
  rule Number_on_X {
    pattern { N[Number, upos=X] }
    commands { del_feat N.Number }
  }
  rule Deixis_on_X {
    pattern { N[Deixis, upos=X] }
    commands { del_feat N.Deixis }
  }
  rule Person_on_X {
    pattern { N[Person, upos=X] }
    commands { del_feat N.Person }
  }

  rule advmod {
    pattern { X -[advmod]-> Y; Y[ExtPos=ADV, upos=VERB] }
    commands { Y.upos=ADV }
  }
}

rule tmp_escape_aux_cop {
  pattern { 
    X [upos=AUX, lemma]
  }
  commands {
    X.xpos = X.lemma;
    del_feat X.lemma
  }
}
