%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The "irregular_expr.grs" file includes packages applying a specific treatment to idioms, titles and translated. What they have in common is the fact that their syntactic behaviour towards the outside world is not regular.
include "utils/irregular_expr.grs"

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Remove all information specific to Enhanced UD.
package eud_to_ud {
  rule deep { % remove add enhanced relations
    pattern { e:N -[enhanced=yes]-> M }
    commands { del_edge e}
  }

  rule empty { % remove empty nodes
    pattern { N [wordform=__EMPTY__, textform=_] }
    commands { del_node N }
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Marking the elements of idioms without syntactic structure.
package idioms{
% Marking the heads. We make the hypothesis that the idiom has the same POS as its head.
  rule idiom_head{
    pattern{H -[fixed]-> *; H[!ExtPos,!Idiom]}
    commands{H.ExtPos=H.upos; H.Idiom=Yes}
  }

% Marking the dependents.
  rule idiom_dependent{
    pattern{* -[fixed]-> D; D[!InIdiom]}
    commands{D.InIdiom=Yes}
  }
  
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% UD sub-relations are renamed as SUD sub-relations or relations.
% The rules are arranged in the alphabetic order of the SUD resulting relations or sub-relations.
package sub_relations {
% comp
%=====
% Sub-relations DEP:COMP are renamed COMP in SUD if they do not start from nominals.
  rule comp_dep {
    pattern { H[upos <> NOUN|PRON]; e:H -[dep:comp]-> D; }
    commands {del_edge e; add_edge H -[comp]-> D}
  }

% Clitic pronouns linked to pronominal verbs.
% Ex: les enfants s'enfuient.
  rule comp-expl_expl-pv{
    pattern{e: H -[expl:pv]-> D}
    commands{del_edge e; add_edge H -[comp@expl]-> D}
  }

% Clitic pronouns expressing the mediopassive redistribution.
% Ex: les maisons se vendent bien en ce moment.
  rule comp-pass_expl-pass{
    pattern{e: H -[expl:pass]-> D}
    commands{del_edge e; add_edge H -[comp@pass]-> D}
  }

% Clausal direct objects or oblique arguments with their subject controlled by their governor.
  rule comp-obj-obl_xcomp {
    pattern { e:H -[xcomp:obj|xcomp:obl]-> D; }
    commands {e.1=comp;e.deep=x}
  }

% All sub-relations of COMP, for which the extension does not change from UD to SUD.
  rule comp {
    pattern { e:H -[advcl:cleft|ccomp:obj|ccomp:obl|ccomp:pred]-> D; }
    commands {e.1=comp}
  }

% In the impersonal diathesis, the deep subject, which is a NSUBJ or CSUBJ dependent in UD, becomes a direct object in SUD with the deep extension AGENT.
% The impersonal diathesis is detected by means of the impersonal subject.
% The UD relation that is renamed as a SUD relation is not a sub-relation but it must be processed before the general processing of relations.
% Ex: Il arrive deux personnes.  - Il m'arrive de faire des erreurs.
  rule comp-obj-agent_subj {
    pattern{e:H -[nsubj|csubj]-> D; H -[expl:subj]-> *}
    commands{del_edge e; add_edge H -[comp:obj@agent]-> D }
  }

% In the impersonal passive diathesis, the deep subject, which is a NSUBJ:PASS or CSUBJ:PASS dependent in UD, becomes an OBJ:PASS dependent in SUD.
% The impersonal diathesis is detected by means of the impersonal subject,which may not be a direct dependent of the main verb, hence the need for several rules.
% Ex: Il sera vendu une grande maison aujourd'hui - Il est prévu de continuer. - Il a été vendu une grande maison aujourd'hui. - Il a été prévu de continuer. - Il peut avoir été vendu une grande maison aujourd'hui.- Il se dit que tu viendras.  Il s'est vendu une grande maison aujourd'hui. - Il a pu se vendre une grande maison aujourd'hui.
  rule comp-obj-pass_subj {
    pattern{e:H -[1=csubj|nsubj, 2=pass]-> D; H -[expl:subj]-> *}
    commands{del_edge e; add_edge H -[comp:obj@pass]-> D; }
  }

% Oblique argument.
  rule comp_obl {
    pattern { e:H -[1=obl, 2=arg|comp]-> D; } % comp pour Spoken
    commands {e.1=comp; e.2=obl}
  }

% Agent complement.
  rule comp_obl-agent {
    pattern { e:H -[1=obl, 2=agent]-> D}
    commands {del_edge e; add_edge H -[comp:obl@agent]-> D}
  }

% Sub-relations DEP:COMP starting from nominals are renamed COMP:OBL in SUD. We make the hypothesis that all arguments of nominals are oblique arguments.
  rule comp_dep_nom {
    pattern { H[upos = NOUN|PRON]; e:H -[dep:comp]-> D; }
    commands {del_edge e; add_edge H -[comp:obl]-> D}
  }

% Predicative non clausal argument.
  rule comp-pred_xcomp {
    pattern { e:H -[xcomp:pred]-> D}
    without{D[upos=AUX|VERB] }
    without{D -[cop]-> *}
    commands {del_edge e; add_edge H -[comp:pred]-> D}
  }

% Predicative clausal argument without control of its subject.
  rule comp-pred_ccomp {
    pattern { e:H -[ccomp:pred]-> D; }
    commands {e.1=comp; e.2=pred}
  }

% Predicative clausal argument with control of the subject by the main verb.
  rule comp-pred-x_xcomp {
    pattern { e:H -[xcomp:pred]-> D;D[upos=VERB] }
    commands {del_edge e; add_edge H -[comp:pred@x]-> D}
  }

% Predicative clausal argument with a copula; the copula subject is controlled by the main verb.
  rule comp-pred-x_xcomp-cop {
    pattern { e:H -[xcomp:pred]-> D;D -[cop]-> D1 }
    commands {del_edge e; add_edge H -[comp:pred@x]-> D}
  }


% mod
%=========

 % Oblique modifier.
  rule mod {
    pattern { e:H -[obl:mod]-> D; }
    commands {e.1=mod; del_feat e.2}
  }

   rule mod-relcl{
     pattern { e:H -[acl:relcl]-> D; }
     commands {del_edge e; add_edge H -[mod@relcl]-> D}
   }


% subj
%=========
% In an impersonal construction, the impersonal subject, which is an EXPL dependent in UD, becomes an  explicit subject in SUD with the deep extension expl.
% Ex: Il arrive deux personnes. - Il faut un bilan. - Il s'agit d'une erreur. - Il a été vendu une grande maison. - il se dit que tu viendras.
  rule subj_expl {
    pattern { e:H -[expl:subj]-> D; }
    without{H -[csubj|nsubj|csubj:pass|nsubj:pass]-> *}
    commands {e.1=subj;e.deep=expl; del_feat e.2}
  }


% unk
%=========
  rule other_expl {
    pattern { e:H -[1=expl, 2<>subj|comp|pass|pv]-> D; }
    commands {del_edge e; add_edge H -[unk@expl]-> D}
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% UD extensions of relations are transformed into deep extensions of SUD relations.
% Examples of cop extensions: cop:locat in UD_Polish-LFG and cop:own in UD_Finnish-* and UD_Karelian-KKPP
package rel_extensions {
% When a relation with an extension is different from COMP, its extension is transformed into a deep extension.
  rule change_ext{
    pattern{e: H -[1=*,2=*]-> D}
    without{ H -[1=aux|comp|subj]-> D}
    without{ H -[conj:emb]-> D}
    commands{ add_edge H -[1=e.1,deep=e.2]-> D; del_edge e}
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% UD relations are renamed as SUD relations or sub-relations.
% Rem: the order of the rules follows the alphabetic order of the names of the resulting relations.
package relations {


%comp:expl
%=========
% Clitic pronoun linked with verbs to form fixed expressions.
% Ex: IL en veut à sa fille.
  rule comp-expl{
    pattern{e: H -[expl]-> D; H[upos=VERB]; D[upos=PRON]}
    commands{del_edge e; add_edge H -[comp@expl]-> D}
  }


%comp:obj
%=========
  rule comp-obj_obj {
    pattern { e:H -[1=obj]-> D; }
    commands { e.1=comp;e.2=obj }
  }

% Direct clausal argument of a verb without control of its subject. We make the assumption that a clausal argument that is not introduced with an adposition is a direct object.
  rule comp-obj_ccomp {
    pattern {e:H -[1=ccomp]-> D; H[upos=VERB]}
    without{D[VerbFom=Part]}% Participles are considered as predicative arguments
    without{H -[obj|comp:obj]-> *}% There is no other direct object.
    without{H -[deep=agent]-> D}% Ex: Il est gêné que tu viennes.
    without{ D -[mark]-> ADP; ADP[upos=ADP]} % The complement is not marked with an adposition
    without{H -[aux@pass|comp:aux@pass]-> *}% A passive verb has no direct object.
    commands{e.1=comp;e.2=obj}
  }

% Direct clausal argument of a verb with control of its subject. We make the assumption that a clausal argument that is not introduced with an adposition is a direct object.
  rule comp-obj_xcomp {
    pattern { e:H -[1=xcomp]-> D; H[upos=VERB]; D[upos=VERB]}
    without{D -[cop]-> *}
    without{D[VerbFom=Part]}% Participles are considered as predicative arguments
    without{H -[obj|comp:obj]-> *}% There is no other direct object.
    without{ D -[mark]-> ADP; ADP[upos=ADP]}
    without{H -[comp:aux@pass|aux@pass]-> *}% A passive verb has no direct object.
    commands {e.1=comp;e.2=obj;e.deep=x}
  }

% Direct clausal argument of a verb with a copula: the coupla subject is controlled by the main verb. We make the assumption that a clausal argument that is not introduced with an adposition is a direct object.
% Ex: Il veut être soldat.
  rule comp-obj_xcomp-cop {
    pattern { e:H -[1=xcomp]-> D; H[upos=VERB];D -[cop]-> D1}
    without{H -[obj|comp:obj]-> *}% There is no other direct object.
    without{ D -[mark]-> ADP; ADP[upos=ADP]}
    without{H -[comp:aux@pass|aux@pass]-> *}% A passive verb has no direct object.
    commands {e.1=comp;e.2=obj;e.deep=x}
  }


% comp:obl
%=========
% Oblique clausal argument of a verb without control of its subject.
% Ex: C'est facile à faire.
  rule comp-obl_ccomp {
    pattern { e:H -[1=ccomp]-> D;  H[upos=VERB]; D -[mark]-> ADP; ADP[upos=ADP]}
    without{D[VerbFom=Part]}% Participles are considered as predicative arguments
    commands {e.1=comp;e.2=obl}
  }

% Oblique clausal argument of a non verbal predicate without control of its subject. We make the assumption that all clausal arguments of non verbal predicates are oblique arguments.
% Ex: Il est heureux que Jean soit venu.
  rule comp-obl_ccomp-non-verb {
    pattern { e:H -[1=ccomp]-> D; H[upos<>VERB]; }
    without{D[VerbFom=Part]}% Participles are considered as predicative arguments
    commands {e.1=comp;e.2=obl}
  }

% Clausal agent complements.
%Ex: fr-ud-train_03013 -  La fédération italienne se dit choquée que le joueur français ait été choisi
  rule comp-obl_ccomp-agent {
    pattern {e:H -[1=ccomp,deep=agent]-> D}
    commands {e.1=comp;e.2=obl}
  }

% Clausal arguments in the presence of a direct object are considered as oblique arguments.
% Je convainc Marc qu'il doit venir.
  rule comp-obl_ccomp-obj {
    pattern {
      e:H -[1=ccomp]-> D;
      H -[obj|comp:obj]-> D1}
    without{D[VerbFom=Part]}% Participles are considered as predicative arguments
    commands {e.1=comp;e.2=obl}
  }

% Clausal arguments of passive verbs are considered as oblique arguments.
% Il est convaincu qu'il doit venir.
  rule comp-obl_ccomp-pass {
    pattern {
      e:H -[1=ccomp]-> D;
      H1 -[aux@pass|comp:aux@pass]-> H}
    without{D[VerbFom=Part]}% Participles are considered as predicative arguments
    commands {e.1=comp;e.2=obl}
  }

  rule comp-obl_iobj {
    pattern { e:H -[1=iobj]-> D; }
    commands {e.1=comp;e.2=obl}
  }

% Clausal arguments with control of their subject and marked with an adposition.
% Il songe à venir.
  rule comp-obl_xcomp {
    pattern { e:H -[1=xcomp]-> D; D[upos=VERB]; D -[mark]-> *}
    without{D[VerbFom=Part]}% Participles are considered as predicative arguments
    commands {e.1=comp;e.2=obl;e.deep=x}
  }

% Clausal arguments with a copula and marked with an adposition; the copula subject is controlled   by the main verb.
% Ex: Il songe à être soldat.
  rule comp-obl_xcomp-cop {
    pattern { e:H -[1=xcomp]-> D; D -[cop]-> D1; D1[upos=VERB]; D -[mark]-> *}
    commands {e.1=comp;e.2=obl;e.deep=x}
  }
% Direct clausal arguments with control of their subject in presence of a direct object are considered as oblique arguments.
  rule comp-obl_xcomp-obj {
    pattern {
      e:H -[1=xcomp]-> D;D[upos=VERB];
       H -[obj|comp:obj]-> D1}
    without{D -[mark]-> *}
    without{D[VerbFom=Part]}% Participles are considered as predicative arguments
    commands {e.1=comp;e.2=obl;e.deep=x}
  }

% Direct clausal arguments of passive verbs with control of their subject are considered as oblique arguments.
  rule comp-obl_xcomp-pass {
    pattern {
      e:H -[1=xcomp]-> D;D[upos=AUX|VERB,VerbForm=Inf];
       AUX -[aux@pass|comp:aux@pass]-> H}
    without{D -[mark]-> *}
    commands {e.1=comp;e.2=obl;e.deep=x}
  }

% comp:pred
%==========
% A direct argument, which is not a verb, is considered  as a predicative complement in SUD.
% Ex: Il semble malade. - Je le considère comme un ami -
  rule comp-pred_xcomp {
    pattern { e:H -[1=xcomp]-> D}
    without{D[upos=VERB] }
    without{D -[cop]-> *}
    commands {e.1=comp;e.2=pred}
  }

% A participle argument with the control of its subject is considered as predicative argument.
% Ex: Il paraît accablé par la mort de sa femme.
  rule comp_pred_part {
    pattern { e:H -[1=xcomp]-> D; D[upos=VERB,VerbForm=Part]}
    commands {add_edge H -[comp:pred@x]-> D; del_edge e}
  }


% mod
%====
% This rule is too strong for nummod, because in many languages, the relation is DET when D precedes H.
  rule mod {
    pattern { e:H -[1=advcl|advmod|amod|nummod]-> D; }
    commands {e.1=mod}
  }

% Modifiers of nominals that are not marked with a conjunction or an adposition are considered as MOD dependents in SUD.
% Ex: un samedi soir - un homme accablé par le décès de sa femme
  rule mod_acl-nmod {
    pattern { e:H -[1=acl|nmod]-> D; }
    without{ D -[case|mark]-> *}
    commands {e.1=mod}
  }


% subj
%=====
  rule subj {
    pattern { e:H -[1=nsubj|csubj]-> D}
    %without{ H1 -[comp:pred]-> H; H1 -[subj@expl]-> *}
    commands {e.1=subj}
  }


% udep
%=====
% Modifiers of nominals that are marked with a conjunction or an adposition are considered as UDEP dependents in SUD.
  rule udep {
    pattern { e:H -[1=acl|nmod]-> D; D -[case|mark]-> *}
    commands {e.1=udep}
  }

% Adverbs that are modifiers of determined words and marked with a conjunction or an adposition are considered as UDEP dependents in SUD.
   rule udep_advmod-det {
     pattern { H -[det]-> *; e:H -[advmod]-> D; D -[case|mark]-> *}
     commands {del_edge e; add_edge H -[udep]-> D}
   }

% Adverbs that are nominal modifiers and marked with a conjunction or an adposition are considered as UDEP dependents in SUD.
   rule udep_advmod-noun {
     pattern { H[upos=NOUN|NUM|PRON|PROPN|X]; e:H -[advmod]-> D; D -[case|mark]-> *}
     commands {del_edge e; add_edge H -[udep]-> D}
   }

   rule udep_obl {
     pattern { e:H -[1=obl]-> D}
     without{H -[deep=agent]-> D}
     commands {e.1=udep}
   }


% unk
%=====
  rule unk {
    pattern { e:H -[1=dep|fixed]-> D; }
    commands {e.1=unk}
  }

  rule unk_expl {
    pattern{e:H -[expl]-> D}
    without{H[upos=VERB]; D[upos=PRON]}
    commands{del_edge e;add_edge H -[unk@expl]-> D;}
  }

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% All aux, case, cop and mark relations are reversed.
% The reverse procedure consists of 5 steps
% 1) package [set_level]: assign a numerical level to each relation which should be reversed
% 2) package [reverse_edges]: reverse edges, add the edge feature REV=Yes. shift_in are done and shift_out is done only on the subsets of reversable relations (case, cop, aux, mark); other shift_out operations are postponed to the next package;
% 3) package [shift_out_edges]: generic rules for selection of relations that should move from the old head onto the new head;
% 4) rule [cleaning]: remove the REV=Yes and the level=* features on edges;
% 5) package [rename_rel]: assign the final SUD labels to reversed edges
package reverse_relations {

  strat main {
    Seq (
      Onf (set_level),
      Onf (reverse_edges),
      Onf (shift_out_edges),
      Onf (cleaning),
      Onf (rename_rel),
    )
  }

  % ---------------------------------------------------------------------------------------------
  package set_level {
    rule r { pattern { e:H -[1=case|aux|mark|cop, !level]-> D } commands { e.level=10 } }
  }
  % ---------------------------------------------------------------------------------------------
  package reverse_edges {
    rule r {
      pattern { e:H -[level=*, !REV]-> FUNCT }
      
      % there is no relation to be reversed with a smaller level
      without { f:H -[level=*, !REV]-> FUNCT1; f.level < e.level; } 
      
      % there is no relation to be reversed at the same level but closer to H
      without { f:H -[level=*, !REV]-> FUNCT1; e.level = f.level; FUNCT << FUNCT1 ; FUNCT1 << H }
      without { f:H -[level=*, !REV]-> FUNCT1; e.level = f.level; FUNCT >> FUNCT1 ; FUNCT1 >> H }
      
      % if there are two relations on the same level, one before, one after the head, the one after is reversed first 
      without { FUNCT << H; f:H -[level=*, !REV]-> FUNCT1; e.level = f.level; H << FUNCT1 }

      commands {
        e.REV=Yes;
        add_edge f: FUNCT -> H; f.label = e.label;
        del_edge e;
        shift_in H =[^IDIOM|TITLE|MWE]=> FUNCT;
        shift_out H =[1=aux|case|cop|mark,!deep,!REV]=> FUNCT;
      }
    }
  }

  % ---------------------------------------------------------------------------------------------
  % The source of some relations must rise from the old head D to the new head H.
  package shift_out_edges{

    % discourse and orphan are always rised
    rule discourse_orphan {
      pattern {
        H -[REV=Yes]-> D;
        e: D -[discourse|orphan]-> N
      }
      commands { add_edge f: H -> N; f.label = e.label; del_edge e }
    }

    % cc are rised
    rule cc {
      pattern {
        H -[REV=Yes]-> D;
        e: D -[cc]-> N;
        N << H; %Ex:  fr-ud-train_12306 - ... sont soit des fanatiques, soit des hypocrites,
      }
      commands { add_edge f: H -> N; f.label = e.label; del_edge e }
    }

    % Agent relations in causative and impersonal constructions with copula.
    % Ex: French-GSD fr-ud-train_02980 - ... c'est au tour des hommes d'Edmund Duke de le faire, ...
    % Ex: French-GSD fr-ud-test_00110 - il est temps de nous rendre nos bienfaits
    % Ex: French-GSD fr-ud-train_00105 - Il n'est pas sûr que cela permettra de changer la réalité
    % Ex: French-GSD fr-ud-train_08302 - C'est fantastique à quel point vous devez faire attention au
    rule agent_aux_caus {
      pattern{
        H -[1=aux, 2=caus, REV=Yes]-> D;
        e: D -[deep=agent]-> N
      }
      commands { add_edge f: H -> N; f.label = e.label; del_edge e }
    }
    rule agent_cop {
      pattern{
        H -[1=cop, REV=Yes]-> D;
        e: D -[deep=agent]-> N
      }
      commands { add_edge f: H -> N; f.label = e.label; del_edge e }
    }

    rule all_mark_embedded{
      pattern {
        H -[1=cop|aux|case,REV=Yes]-> D;
        e: D -[1=dislocated|parataxis|subj|vocative]-> N;}
      without { D -[parataxis]-> N; H1 -[1 <> cop]-> H; H -[1=case]-> D }
      without { N[InTitle=Yes] } % French-GSD fr-ud-train_13022 - ...très connu dans les rôles de Bo Duke de Shérif, fais-moi peur !
      commands { add_edge f: H -> N; f.label = e.label; del_edge e }
    }

    rule comp_cleft{
      pattern {
        H -[1=cop|aux|case,REV=Yes]-> D;
        e: D -[comp:cleft]-> N;}
      without { N[InTitle=Yes] } % French-GSD fr-ud-train_13022 - ...très connu dans les rôles de Bo Duke de Shérif, fais-moi peur !
      commands { add_edge f: H -> N; f.label = e.label; del_edge e }
    }

    % Relations with their source D after the head of a subordinated clause and their dependent N before.
    rule all_mark_outside_left{
      pattern {
        H -[1=mark,REV=Yes]-> D;
        e: D -[1=dislocated|subj|vocative]-> N;
        N << H; H << D
      }
      commands { add_edge f: H -> N; f.label = e.label; del_edge e }
    }

    % Relations with their source D before the head of a subordinated clause and their dependent N afterwards.
    rule all_mark_outside_right{
      pattern {
        H -[1=mark,REV=Yes]-> D;
        e: D -[1=dislocated|subj]-> N;
        D << H; H << N
      }
      commands { add_edge f: H -> N; f.label = e.label; del_edge e }
    }

    % Relations that rise when their source D is on the right of H and when their dependent N is on the right of D.
    rule H_D_N_mod {
      pattern {
        H -[1<>mark, REV=Yes]-> D;  
        e: D -[1=mod]-> N; 
        H << D; D << N
      }
      without { D -[mod@relcl]-> N }
      without { D -> X; N << X } % rising must not entail non projectivity
      without { H -[1=case]-> D; N[upos<>ADP|SCONJ] }
      without { H -[1=cop]-> D; N[upos<>ADP|ADV|AUX|SCONJ|VERB] }
      without { H -[1=cop]-> D; N[upos=AUX|VERB]; D -[!deep]-> N} % the only dependencies that can rise with verbs are MOD@X
      without { H -[1=cop]-> D; N[upos=AUX|VERB]; D -[deep <> x]-> N}% the only dependencies that can rise with verbs are MOD@X
      without { N[InTitle=Yes]; H[!InTitle] } % A vérifier
      without {H -[1=case|mark]-> D; H1 -[IDIOM]-> N; H1 -[HEAD]-> H }
      commands { add_edge f: H -> N; f.label = e.label; del_edge e }
    }

    % Relations that rise when their source D is on the right of H and when their dependent N is on the right of D.
    rule H_D_N_punct {
      pattern {
        H -[REV=Yes]-> D;  
        e: D -[1=punct]-> N; 
        H << D; D << N
      }
      without { D -> X; N << X} % rising must not entail non projectivity
      without { D -[punct]-> X; X << D; N.lemma = X.lemma}
      without { D -[punct]-> X; X << D; N.lemma = ")"; X.lemma = "("}
      without { D -[punct]-> X; X << D; N.lemma = "»"; X.lemma = "«"}
      without { D -[punct]-> X; X << D; N.lemma = "]"; X.lemma = "["}
      without { N[InTitle=Yes]; H[!InTitle]}% A vérifier
      without { H -[1=case|mark]-> D; H1 -[IDIOM]-> N; H1 -[HEAD]-> H}
      commands { add_edge f: H -> N; f.label = e.label; del_edge e }
    }

    % Relations that rise when their source D is on the right of H and when their dependent N is between D and H.
    rule H_N_D { 
      pattern{
        H -[1=aux|cop,REV=Yes]-> D;
        e: D -[mod]-> N;
        H << N; N << D}
      without{ H -[1=cop]-> D; N[upos=ADJ]; D[upos=NOUN] }
      without{ D -> X; H << X; X << N}
      commands { add_edge f: H -> N; f.label = e.label; del_edge e }
    }

    % Relations that rise when their source D is on the left of H and when their dependent N is on the right of H.
    rule D_H_N{
      pattern {
        H -[REV=Yes]-> D;
        e: D -[1=mod|punct]-> N;
        D << H; H << N
      }
      commands { add_edge f: H -> N; f.label = e.label; del_edge e }
    }

    % Relations that rise when their source D is on the left of N and when their dependent N is also on the left of H.
    rule D_N_H {
      pattern {
          H -[1=cop,REV=Yes]-> D;
          e: D -[1=mod]-> N;
          D << N; N << H
        }
      commands { add_edge f: H -> N; f.label = e.label; del_edge e }
    }

    % Relations that rise when their source D is on the right of H and when their dependent N is on the left of H.
    rule N_H_D {
      pattern {
        H -[REV=Yes]-> D;  
        e: D -[1=mod|orphan|punct|reparandum|udep]-> N; 
        N << H; H << D
      }
      commands { add_edge f: H -> N; f.label = e.label; del_edge e }
    }

    % Relations that rise when their source D is on the left of H and when their dependent N is on the left of D.
    rule N_D_H {
      pattern{
        H -[REV=Yes]-> D;
        e: D -[1=mod|punct]-> N;
        N << D; D << H
      }
      commands { add_edge f: H -> N; f.label = e.label; del_edge e }
    }

    % Conj relations in the general case.
    rule conj{
      pattern{
        H -[REV=Yes]-> D;
        e: D -[1=conj]-> N;
        D.upos <> N.upos;
      }
      without { D[upos=NOUN|PRON|PROPN|NUM|X]; N[upos=NOUN|PRON|PROPN|NUM|X] }
      without { D[upos=ADJ|ADP]; N[upos=VERB,VerbForm=Part] }
      without { D[upos=VERB,VerbForm=Part]; N[upos=ADJ|ADP] }
      without { D[upos=ADP|ADV]; N[upos=ADP|ADV]  }
      without { D[upos=AUX|VERB]; N[upos=AUX|VERB]; N.VerbForm=D.VerbForm  }
      commands { add_edge f: H -> N; f.label = e.label; del_edge e }
    }

    % Conj relations when the conjunct heads are verbs.
    rule conj_verb {
      pattern {
        H -[REV=Yes]-> D;
        e: D -[1=conj]-> N;
        H << D;
        D[upos=AUX|VERB, VerbForm];
	%N[upos=AUX|VERB, VerbForm];
        %D.VerbForm <> N.VerbForm
      }
      without{N[upos=AUX|VERB, VerbForm];  D.VerbForm = N.VerbForm}
      commands { add_edge f: H -> N; f.label = e.label; del_edge e }
    }

    rule shared{
      pattern{H -[REV=Yes]-> D; D[Shared=Yes]}
      commands{H.Shared=Yes; del_feat D.Shared}
    }
  }

  % ---------------------------------------------------------------------------------------------
  package cleaning {
    % Removing the mark REV for reversed relations.
    rule remove_rev {
      pattern { e: M -[REV=Yes]-> N }
      commands{del_feat e.REV}
    }
  
    % Removing the level feature
    rule remove_level {
      pattern { e: M -[level=*]-> N }
      commands{del_feat e.level}
    }
  }

  % ---------------------------------------------------------------------------------------------
  % Renaming the reversed relations
  package rename_rel {
    % Next two rules: potential subrel for mark/case/cop are already in the "deep" feature
    rule case-mark {
      pattern { e:M -[1=case|mark]-> N }
      commands { 
        e.1 = comp;
        e.2 = obj;
      }
    }

    rule cop {
      pattern { e:M -[1=cop]-> N }
      commands { 
        e.1 = comp;
        e.2 = pred;
      }
    }

    % Next two rules: potential subrel for aux are moved now in the "deep" feature
     rule aux {
       pattern { e:M -[aux]-> N }
       commands { add_edge M -[comp:aux]-> N; del_edge e }
     }
 
     rule aux_with_subrel {
       pattern { e:M -[1=aux,2=*]-> N }
       commands { add_edge M -[1=comp,2=aux,deep=e.2]-> N; del_edge e }
     }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Mark the left dependents of a coordination with the feature Shared=Yes.
package shared_left_conj-dep {
% The general case
% Ex:  SUD_English-GUM GUM_voyage_chatham-12 - In[D] 1835 Maori settlers from the mainland arrived[C1], massacred[C2] and enslaved the Moriori.
% Ex: SUD_English-GUM GUM_news_clock-10 - Police[D] arrested[C1] and questioned[C1] the student.
% Ex: SUD_English-GUM GUM_bio_jespersen-12 - Academic[D] life[C1] and work[C2]
  rule shared_dep {
    pattern {
      C1 -[1=conj]-> C2;
      e:C1 -[^punct|HEAD|IDIOM]-> D; D[!InIdiom, !Shared]; D << C1}
    without{C1 -[1=comp|mod]-> D; D[upos=PRON, PronType <> Int|Rel]}
    without{ C1 -[1 <> comp|subj]-> D; f: C2 -> D2; D2[upos <> ADV]; f.1 =e.1; D2 << C2}
    without{ C1 -[1 =comp|subj]-> D; f: C2 -> D2; f.1 =e.1}
   without{e.1=mod; D[upos=ADJ|NUM]; C2 -[1=det]-> D2; D2 << C2}
    without{e.1=mod; D[upos=ADJ|NUM]; C2[upos<> NOUN|PROPN]}%  French-GSD fr-ud-dev_00994 : Bonne nourriture mais le temps d'attente entre les plats a été très long.
    without{C1-[1=det]-> D; C2[upos<> NOUN|PROPN]}% French-GSD fr-ud-test_00032 : faisait vivre toute cette région et bien au-delà
    commands{D.Shared=Yes}
  }

% The left dependent is a punctuation sign, which is not embedding.
% Ex: SUD_English-GUM GUM_fiction_pag-88 - The rock dropped to the ground,[P1] blood-slick[C1] and glistening[C2].
  rule shared_punct {
    pattern {
      C1 -[1=conj]-> C2;
      C1 -[punct]-> P1; P1 << C1}
    without{ C1 -[punct]-> P2; P2 >> C1}
    without{P1[Shared]}
    commands{P1.Shared=Yes}
  }

% The left dependent is an embedding punctuation sign.
% Ex: SUD_English-GUM GUM_bio_byron-21 - he described the affair as "[P1]a violent, though pure love[C1] and passion[C2]"[P2]
  rule shared_punct-emb {
    pattern {
      C1 -[1=conj]-> C2;
      C1 -[punct]-> P1; P1 << C1;
      %P1[lemma="\""|"("|"«"];
      C1 -[punct]-> P2; P2 >> C2}
    without{P1[Shared]}
    commands{P1.Shared=Yes}
  }

% The left dependent precedes another left dependent, which is shared by the conjuncts.
% Ex: SUD_English-GUM GUM_bio_gordon-28 - At[D2] the end of his life the Tsar[D1] ... was[C1] with him when he died, and with his own hands closed[C2] his eyes.
  rule shared_shared {
    pattern {
      C1 -[1=conj]-> C2;
      C1 -> D1; D1 << C1; D1[Shared=Yes];
      C1 -> D2; D2 << D1; }
    without{D2[Shared]}
    commands{D2.Shared=Yes}
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Mark the left dependents of the head conjunct of a coordination, which are not dependents of the coordination, with the feature Shared=No.
package unshared_left_conj-dep {
% Pronouns that are left modifiers or complements of the head of the first conjunct are not dependents of the coordination.
% Ex: SUD_French-GSD fr-ud-train_02634 - L'accueil y[D] est[C1] chaleureux et les prix défient[C2] toute concurrence !
  rule unshared_comp-mod-pron{
    pattern {
      C1 -[1=conj]-> C2;
      e:C1 -[1=comp|mod]-> D; D[upos=PRON, PronType <> Int|Rel, !Shared]; D << C1}
    commands{D.Shared=No}
  }

% Left arguments of the first conjunct are not dependents of the coordination, if there is a similar dependent of the second conjunct.
% Ex: SUD_English-GUM GUM_fiction_honour-42 - Feet[D] moved[C1] and Chalmers[D2] felt[C2] his stomach lurch.
  rule unshared_comp-subj{
    pattern {
      C1 -[1=conj]-> C2;
      e:C1 -[1=comp|subj]-> D; D[!Shared]; D << C1; f:C2->D2; f.1=e.1}
    commands{D.Shared=No}
  }

% Dependents of the first conjunct are not dependents of the coordination,if there is a similar left dependent of the second conjunct.
% Ex: SUD_English-GUM GUM_whow_quidditch-57 - Find a[D] quarter[C1] or another[D2] small coin[C2].
  rule unshared_dep{
    pattern {
      C1 -[1=conj]-> C2;
      e:C1 -[1<>comp|punct|subj|IDIOM|HEAD]-> D; D[!Shared]; D << C1;
      f:C2->D2; D2[upos <> ADV]; f.1=e.1; D2 << C2}
    commands{D.Shared=No}
  }
  
% Adjectives that are left modifiers of the head of the first conjunct are not dependents of the coordination, if there is a determiner of the head of the second conjunct at its left.
% Ex: SUD_English-GUM GUM_interview_shalev-46 - You also wrote two collections of short[D] stories[C1] and a[D2] novel[C2].
  rule unshared_dep-adj1{
    pattern {
      C1 -[1=conj]-> C2;
      C1 -[1=mod]-> D; D[upos=ADJ|NUM, !Shared]; D << C1;
      C2[upos= NOUN|PROPN];
      C2 -[1=det]-> D2; D2 << C2}
    commands{D.Shared=No}
  }

% Adjectives that are left modifiers of the head of the first conjunct are not dependents of the coordination,if the head of the second conjunct is not a noun.
% Ex: SUD_English-GUM GUM_voyage_thailand-31 - your dress should ... cover your entire[D] torso[C1] and most[C2] of your limbs.
  rule unshared_dep-adj2{
    pattern {
      C1 -[1=conj]-> C2;
      C1 -[1=mod]-> D; D[upos=ADJ|NUM, !Shared]; D << C1}
    without{C2[upos= NOUN|PROPN]}
    commands{D.Shared=No}
  }

% Determiners of the head of the first conjunct are not dependents of the coordination, if the head of the second conjunct is not a noun.
% Ex: SUD_English-GUM GUM_whow_ballet-6 - ... the[D] basic positions[C1], and some[C2] of the first techniques you're likely to encounter in ballet
  rule unshared_det{
    pattern {
      C1 -[1=conj]-> C2;
      C1 -[1=det]-> D; D[!Shared]; D << C1}
    without{C2[upos= NOUN|PROPN]}
    commands{D.Shared=No}
  }

% Punctuation signs that dependent of the first conjunct are not dependents of the coordination,if the head of this conjunct has another dependent, which is punctuation sign before the second conjunct.
% Ex: SUD_English-GUM GUM_interview_dungeon-19 - Yeah, "[P1]think[C1] again"[P2] or something[C2] like that.
  rule unshared_punct{
    pattern {
      C1 -[1=conj]-> C2;
      C1 -[1=punct]-> P1; P1[!Shared]; P1 << C1;
       C1 -[1=punct]-> P2; C1 << P2; P2 << C2}
    commands{P1.Shared=No}
  }

% The left dependent follows another left dependent, which is not shared by the conjuncts.
% Ex: SUD_English-GUM GUM_whow_overalls-25 - The bib has a[D2] wallet[D1] pocket[C1] and a watch pocket[C2].
  rule unshared_unshared {
    pattern {
      C1 -[1=conj]-> C2;
      C1 -> D1; D1 << C1; D1[!Shared];
      C1 -> D2; D2 << D1; D2[Shared=No]}
    commands{D1.Shared=No}
  }

}
  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Move the right dependents of a conjunction from the left conjunct to the right conjunct. Dependencies CONJ, DISCOURSE, PARATAXIS and PUNCT are not moved.
package minimize_right_conj-dep {

% The right shared element directly depends on the head of the first conjunct.
  rule minimize_direct {
    pattern {
      C1 -[1=conj]-> C2;
      e:C1 -[^conj|conj:emb|discourse|parataxis|punct]-> D; C2 << D}
    without { C1 -[1=conj]-> C; C2 << C ; C << D} % Ex :fr-ud-train_03266, fr-ud-train_02016
    commands {
      add_edge f:C2 -> D; f.label = e.label;
      del_edge e;
      D.Shared=Yes
    }
  }


% The shared element depends on the head of the first conjunct via a MOD dependency.
  rule minimize_indirect_mod {
    pattern {
      C1 -[1=conj]-> C2;
      C1 -[mod]-> D1; D1 << C2;
      C2 -[mod]-> D2; D2 << C2; %Ex:fr-ud-dev_01562 - ... plus savoureuse (73%) et plus sucrée (68%) que les autres fraises
      e:D1 -[^conj|conj:emb|discourse|parataxis|punct]-> D; C2 << D}
    without { C1 -[1=conj]-> C; C2 << C ; C << D} % Ex :fr-ud-train_03266, fr-ud-train_02016
    commands {
      add_edge f:D2 -> D; f.label = e.label;
      del_edge e;
      D.Shared=Yes
    }
  }

% The shared element depends on the head of the first conjunct via a COMP:OBJ dependency.
  rule minimize_indirect_conj-obj {
    pattern {
      C1 -[1=conj]-> C2;
      C1 -[1=comp,2=obj]-> D1; D1 << C2;
      C2 -[1=comp,2=obj]-> D2;
      e:D1 -[^conj|conj:emb|discourse|parataxis|punct]-> D; C2 << D}
    without { C1 -[1=conj]-> C; C2 << C ; C << D} % Ex :fr-ud-train_03266, fr-ud-train_02016
    commands {
      add_edge f:D2 -> D; f.label = e.label;
      del_edge e;
      D.Shared=Yes
    }
  }


}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Mark embedded conj relations with the extension "emb".
rule add_conj_emb{
  pattern {
    N1 -[conj|conj:emb]-> N2;
    e: N2 -[conj]-> N3;
  }
  commands {
    del_edge e; add_edge N2 -[conj:emb]-> N3;
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dependencies of type CONJ, FIXED and FLAT:NAME grouped into a bouquet are reorganized into a chain.
package chained_relations {
  rule conj {
    pattern {H -[1=conj]-> D1;e: H -[1=conj]-> D2;D1 << D2}
    without {H -[1=conj]-> D;D1 << D; D << D2}
    without {H -[1=conj]-> D;D2 << D}
    commands {
      add_edge f:D1 -> D2; f.label = e.label;
      del_edge e;
    }
  }

  rule fixed {
    pattern {
      H -[unk]-> D1; * -[IDIOM]-> D1;
      e: H -[unk]-> D2;D1 << D2}
    without{H -[unk]-> D; * -[IDIOM]-> D;D1 << D; D << D2}
    without{H -[unk]-> D; * -[IDIOM]-> D;D2 << D;}
    commands{del_edge e;add_edge D1 -[unk]-> D2}
  }

  rule flat {
    pattern {H -[1=flat]-> D1;e: H -[1=flat]-> D2;D1 << D2}
    without {H -[1=flat]-> D;D1 << D; D << D2}
    without {H -[1=flat]-> D;D2 << D}
    commands {add_edge f: D1 -> D2; f.label=e.label; del_edge e}
  }

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% All remaining UD relations are renamed UNK in SUD
rule unk_rel{
  pattern{e:H -[1<>appos|cc|clf|comp|compound|conj|det|discourse|dislocated|flat|goeswith|list|mod|orphan|parataxis|punct|reparandum|root|subj|udep|unk|vocative|CONV|HEAD|IDIOM|TITLE]-> D}
  commands{del_edge e; add_edge H -[unk]-> D}
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
strat main {
  Seq (
    Onf (eud_to_ud),
    Onf (idioms),
    specific_expr_init, % Initialization of a specific treatment for MWE, titles and translated words.
    Onf (sub_relations), % Package SUB_RELATIONS must precede package REL_EXTENSIONS because this package swat extensions on level 2.
    Onf (rel_extensions),
    Onf (relations), % Package RELATIONS must precede REVERSE_RELATIONS.MAIN because the renaming of some relations depends on the cooccurrence with other relations (nsubj, csubj in the impersonal diathesis for instance)
    reverse_relations.main, % Reversing aux, case, cop and mark relations.
    Onf(shared_left_conj-dep),
    Onf(unshared_left_conj-dep),
    Onf (minimize_right_conj-dep), % Package MINIMIZE_CONJ_DEP must follow strategy REVERSE_RELATIONS.MAIN because the shared dependents can depend on relation inversions.Moreover, a dependance can shift from a coordination to an ascendant. Ex: fr-ud-dev_00446 -entre 3 et 6 généralement
    Onf (add_conj_emb), % Package ADD_CONJ_EMB must follow REVERSE_RELATIONS.MAIN because it depends on head changes ; Ex: UD_French-GSD fr-ud-dev_00751
    Onf (chained_relations),% Package CHAINED_RELATIONS must follow package SHIFT_RULES because it can entail a wrong coordination between two elements because of errors in head changes (UD_French-GS: fr-ud-dev_00131).
    specific_expr_close, % Closing a specific treatment for MWE, titles and translated words.
    Onf (unk_rel),
  )
}
