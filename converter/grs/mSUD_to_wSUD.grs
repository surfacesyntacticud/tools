strat main {
  Seq (
    Onf(init),
    Onf (DerAff),
    Onf (p),
    Onf (final_word),
    Onf (empty_lemma),
  )
}

package init {
  rule pref {
    pattern { X[form=re".+-"]; }
    commands { X.form = X.form[:-1] }
  }
  rule suff {
    pattern { X[form=re"-.+"];}
    commands { X.form = X.form[1:] }
  }

  % replace no_lemma by empty lemma for uniform rules later
  % no_lemma is restored in final package
  rule empty_lemma {
    pattern { X [form<>"__0__", !lemma]}
    commands { X.lemma = "" }
  }
}

package DerAff {
  rule Root_DerAff {
    pattern { X2 [TokenType=DerAff, DerPos]; X1 < X2; X2 -> X1 }
    commands { X2.upos = X2.DerPos; del_feat X2.DerPos }
  }
}

package p {
  rule fwd_Root {
    pattern { 
      X1[nWord]; X2[nWord]; X1 < X2; X1.nWord = X2.nWord; X1 -> X2;
      X2[TokenType=Root]
    }
    commands {
      X1.form = X1.form + X2.form;                      % concatenate the surface form
      X1.wordform = X1.wordform + X2.wordform;          % concatenate the surface form
      X1.lemma = X1.lemma + X2.lemma;                   % concatenate the surface lemma
      append_feats "_" X2 =[re"Translit\|Tone"]=> X1;   % concatenate the surface Translit and Tone
      append_feats X2 =[re"Gloss\|Rx"]=> X1;
      shift X2 ==> X1;
      X1.upos = X2.upos;
      del_node X2;
    }
  }
  rule fwd_DerAff {
    pattern { 
      X1[nWord]; X2[nWord]; X1 < X2; X1.nWord = X2.nWord; X1 -> X2;
      X2[TokenType=DerAff, DepPos]
    }
    commands {
      X1.form = X1.form + X2.form;                      % concatenate the surface form
      X1.wordform = X1.wordform + X2.wordform;          % concatenate the surface form
      X1.lemma = X1.lemma + X2.lemma;                   % concatenate the surface lemma
      append_feats "_" X2 =[re"Translit\|Tone"]=> X1;   % concatenate the surface Translit and Tone
      append_feats X2 =[re"Gloss\|Rx"]=> X1;
      shift X2 ==> X1;
      X1.upos = X2.DerPos;
      del_node X2;
    }
  }
  rule fwd_else {
    pattern { 
      X1[nWord]; X2[nWord]; X1 < X2; X1.nWord = X2.nWord; X1 -> X2;
    }
    without { X2[TokenType=Root|DerAff] }
    commands {
      X1.form = X1.form + X2.form;                      % concatenate the surface form
      X1.wordform = X1.wordform + X2.wordform;          % concatenate the surface form
      X1.lemma = X1.lemma + X2.lemma;                   % concatenate the surface lemma
      append_feats "_" X2 =[re"Translit\|Tone"]=> X1;   % concatenate the surface Translit and Tone
      append_feats X2 =[re"Gloss\|Rx"]=> X1;
      shift X2 ==> X1;
      del_node X2;
    }
  }

  rule back_Root {
    pattern { 
      X1[nWord]; X2[nWord]; X1 < X2; X1.nWord = X2.nWord; X2 -> X1;
      X1[TokenType=Root]
    }
    commands {
      X2.form = X1.form + X2.form;                      % concatenate the surface form
      X2.wordform = X1.wordform + X2.wordform;          % concatenate the surface form
      X2.lemma = X1.lemma + X2.lemma;                   % concatenate the surface lemma
      prepend_feats "_" X1 =[re"Translit\|Tone"]=> X2;  % concatenate the surface Translit and Tone
      prepend_feats X1 =[re"Gloss\|Rx"]=> X2;
      shift X1 ==> X2;
      X2.upos = X1.upos;
      del_node X1;
    }
  }
  rule back_DerAff {
    pattern { 
      X1[nWord]; X2[nWord]; X1 < X2; X1.nWord = X2.nWord; X2 -> X1;
      X1[TokenType=RerAff, DerPos]
    }
    commands {
      X2.form = X1.form + X2.form;                      % concatenate the surface form
      X2.wordform = X1.wordform + X2.wordform;          % concatenate the surface form
      X2.lemma = X1.lemma + X2.lemma;                   % concatenate the surface lemma
      prepend_feats "_" X1 =[re"Translit\|Tone"]=> X2;  % concatenate the surface Translit and Tone
      prepend_feats X1 =[re"Gloss\|Rx"]=> X2;
      shift X1 ==> X2;
      X2.upos = X1.DerPos;
      del_node X1;
    }
  }

  rule back_else {
    pattern { 
      X1[nWord]; X2[nWord]; X1 < X2; X1.nWord = X2.nWord; X2 -> X1;
    }
    without { X1[TokenType=Root|DerAff] }
    commands {
      X2.form = X1.form + X2.form;                      % concatenate the surface form
      X2.wordform = X1.wordform + X2.wordform;          % concatenate the surface form
      X2.lemma = X1.lemma + X2.lemma;                   % concatenate the surface lemma
      prepend_feats "_" X1 =[re"Translit\|Tone"]=> X2;  % concatenate the surface Translit and Tone
      prepend_feats X1 =[re"Gloss\|Rx"]=> X2;
      shift X1 ==> X2;
      del_node X1;
    }
  }

  rule fwd_nohead {
    pattern { X1[nWord]; X2[nWord]; X1 < X2; X1.nWord = X2.nWord; }
    without { * -> X2 }
    without { X2 -> X1 }
    commands {
      X1.form = X1.form + X2.form;                      % concatenate the surface form
      X1.wordform = X1.wordform + X2.wordform;          % concatenate the surface form
      X1.lemma = X1.lemma + X2.lemma;                   % concatenate the surface lemma
      append_feats "_" X2 =[re"Translit\|Tone"]=> X1;   % concatenate the surface Translit and Tone
      append_feats X2 =[re"Gloss\|Rx"]=> X1;
      shift X2 ==> X1;
      del_node X2;
    }
  }

  rule back_nohead {
    pattern { X1[nWord]; X2[nWord]; X1 < X2; X1.nWord = X2.nWord; }
    without { * -> X1 }
    without { X1 -> X2 }
    commands {
      X2.form = X1.form + X2.form;                      % concatenate the surface form
      X2.wordform = X1.wordform + X2.wordform;          % concatenate the surface form
      X2.lemma = X1.lemma + X2.lemma;                   % concatenate the surface lemma
      prepend_feats "_" X1 =[re"Translit\|Tone"]=> X2;  % concatenate the surface Translit and Tone
      prepend_feats X1 =[re"Gloss\|Rx"]=> X2;
      shift X1 ==> X2;
      del_node X1;
    }
  }
}

rule final_word {
  pattern { X [Word] }
  commands { X.form = X.Word; del_feat X.Word }
}

% restore no_lemma
rule empty_lemma {
  pattern { X [lemma= ""]}
  commands { del_feat X.lemma }
}
