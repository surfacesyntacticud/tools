%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The "irregular_expr.grs" file includes packages applying a specific treatment to multi-word expressions (MWE), titles (TITLE) and translated (TRANS). What they have in common is the fact that their syntactic behaviour towards the outside world is not regular.
include "irregular_expr.grs"


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% For the internal elements of MWE, the deep extension fixed on the incoming relation is replaced with feature INMWE=Yes.
% rules modify annotation recursively from head to avoid to tranform the special SUD relation comp@fixed used for some expletives
package remove_deep_fixed{

  rule init {
    pattern { H[_MISC_EXTPOS,_MISC_Type=MWE]; e:H -[deep=fixed]-> D;D[!_MISC_INMWE]}
    without { H -[1=unk]-> D}
    commands {del_feat e.deep; D._MISC_INMWE=Yes}
  }

  rule init_backoff { % if _MISC_Type feature is missing
    pattern { H[_MISC_EXTPOS, !_MISC_Type]; e:H -[deep=fixed]-> D;D[!_MISC_INMWE]}
    without { H -[1=unk]-> D}
    commands {del_feat e.deep; D._MISC_INMWE=Yes}
  }

  rule propagate {
    pattern { H[_MISC_INMWE=Yes]; e:H -[deep=fixed]-> D;D[!_MISC_INMWE]}
    without { H -[1=unk]-> D}
    commands {del_feat e.deep; D._MISC_INMWE=Yes}
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dependencies of coordinations to their right are marked in SUD with feature Shared=Yes and they are attached at the rightmost conjunct. In UD, they are attached at the head of the coordination and feature  Shared=Yes is useless.
package shared {
% The shared dependent is directly attached at the head of the last conjunct.
  rule move_relation {
    pattern {
      N1 -[1=conj]-> N2;
      e: N2 -> D; D[Shared=Yes]}
  %  without{ N2 -[orphan]-> D; H -[^ conj]-> N1} %Ex : SUD_FRENCH-GSD fr-ud-train_13715
    commands {add_edge e: N1 -> D; del_edge e}
  }

% The shared dependent is attached at the head of the last conjunct via a COMP:OBJ relation.
  rule move_compobj_distant-relation {
    pattern {
      N1 -[1=conj]-> N2;
      N1 -[1=comp,2=obj]-> D1;
      N2 -[1=comp,2=obj]-> D2;
      e: D2 -> D; D[Shared=Yes]}
    commands {add_edge e: D1 -> D;del_edge e;}
  }

% The shared dependent is attached at the head of the last conjunct via a MOD relation.
  rule move_mod_distant-relation {
    pattern {
      N1 -[1=conj]-> N2;
      N1 -[1=mod]-> D1;
      N2 -[1=mod]-> D2;
      e: D2 -> D; D[Shared=Yes]}
    commands {add_edge e: D1 -> D;del_edge e;}
  }
  
% % The shared dependent is attached at the head of the last conjunct via a relation different from COMP:OBJ and MOD.
%   rule move_other_distant-relation {
%     pattern {
%       N1 -[1=conj]-> N2;
%       N2 -> D2;
%       e: D2 -> D; D[Shared=Yes]}
%     without{N2 -[1=mod]-> D2}
%     without{N2 -[1=comp,2=obj]-> D2}
%     commands {add_edge e: N1 -> D;del_edge e;}
%   }

% After the shared dependent has moved to the first conjunct, all features "Shared" are removed.
  rule remove_shared {
    pattern {D[Shared=Yes]}
    without {N1 -[1=conj]-> N2; N2 -> D}
    without{N1 -[1=conj]-> N2; N2 -> D2; D2 ->D}
    commands {del_feat D.Shared}
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Feature "nom" is used to deal with all nominals in a uniform way.
package nom_init {
% All adverbs, numerals and symbols with a COMP:OBJ function are nominals.
  rule nom_comp_obj {
    pattern {A[upos=ADV|SYM|NUM,!nom]; H -[1=comp, 2=obj]-> A}
    without{ H[upos=ADP|SCONJ]; A[upos=ADV]}
    commands {A.nom=y}
  }

% All words with a determiner are nominals.
  rule nom_det {
    pattern {N[upos<>NOUN|PRON|PROPN|X,!nom]; N -[det]-> *}
    commands {N.nom=y}
  }

% All words with NOUN, PRON, PROPN, SYM, X as POS are nominals.
  rule nom_noun {
    pattern {N[upos=NOUN|PRON|PROPN|X,!nom]}
    commands {N.nom=y}
  }

% All numerals following their gouvernor are nominals.
  rule nom_num_after {
    pattern {N[upos=NUM,!nom]; H -> N; H << N}
    commands {N.nom=y}
  }

% All numerals preceding their governor with a relation that is normally used for nominals are nominals.
  rule nom_num_before {
    pattern {N[upos=NUM,!nom]; H -[comp|comp:obj|comp:obl|subj|udep]-> N; H >> N}
    commands {N.nom=y}
  }

% All numerals preceding their governor with a relation that is normally used for nominals are nominals.
  rule nom_num_verb {
    pattern {N[upos=NUM,!nom]; H[upos=AUX|VERB]; H -[mod]-> N}
    commands {N.nom=y}
  }
% When a MWE is a nominal, the node representing this expression is marked as a nominal.
  rule nom_mwe{
    pattern{H -[expr]-> N; H[!nom]; N[_MISC_Type=MWE, _MISC_EXTPOS=NOUN|PRON|PROPN|SYM|X]}
    commands{H.nom=y}
  }

% A node representing a title is marked as a nominal.
  rule nom_title{
    pattern{H -[expr]-> N; H[!nom]; N[_MISC_Type=Title]}
    commands{H.nom=y}
  }

% All adverbs, numerals and symbols with a SUBJ function are nominals.
  rule nom_subj {
    pattern {A[upos=ADV|SYM|NUM,!nom]; V -[1=subj]-> A}
    commands {A.nom=y}
  }

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dependencies of type FLAT_NAME, FIXED or CONJ that are chained are reorganized into bouquets.
package unchained_relations {
  rule flat_name {
    pattern { H -[flat:name]-> D1; e: D1 -[flat:name]-> D2; }
    without { * -[flat:name]-> H; }
    commands { del_edge e; add_edge H -[flat:name]-> D2; }
  }

  rule fixed {
    pattern { H -[unk@fixed]-> D1; e: D1 -[unk@fixed]-> D2; }
    without { * -[unk@fixed]-> H; }
    commands { del_edge e; add_edge H -[unk@fixed]-> D2; }
  }

  rule flat {
    pattern { H -[flat]-> D1;e: D1 -[flat]-> D2 }
    commands { del_edge e; add_edge H -[flat]-> D2 }
  }

  rule conj {
    pattern { H -[1=conj]-> D1;e: D1 -[conj]-> D2 }% Dependency H -> D1 can be an embedded coordination.
    commands { del_edge e; add_edge H -[conj]-> D2 }
  }

% Embedded coordinations.
  rule conj_emb {
    pattern { H -[conj:emb]-> D1;e: D1 -[conj:emb]-> D2 }
    commands { del_edge e; add_edge H -[conj:emb]-> D2 }
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The relations with prepositions and conjunction of subordination as their heads are reversed.
package reverse_case_mark {
% The heads are reversed from the most internal to the most external. The source and the target of the reversed relation are marked "reversed = y" so that loops are not possible.
  rule rev_head {
    pattern {e:H -[1=comp,2=obj, !rev]-> D; H[upos= ADP|CCONJ|PART|SCONJ]}
    without{D[upos= ADP|CCONJ|PART|SCONJ]; D -[1=comp,2=obj]-> D1}
    commands {
      e.rev=y;
      add_edge e:D -> H;
      del_edge e;
      shift_in H =[^MWE|TITLE|CONV]=> D;
      shift_out H =[1=case|mark]=> D;
%      shift_out H =[^conj:dicto|expr|goeswith|orphan|reparandum|unk@fixed|HEAD|MWE|TITLE|TRANS]=> D;
    }
  }

}

%%%%%%%%%%%%%%%%%%%%%
% The source of some relations must rise from the old head D to the new head H.
package shift_out_edges{
  rule all{
    pattern{
      H -[rev=y]-> D;
      e: D -> D1}
     % e:D -[^ conj|conj:dicto|expr|goeswith|reparandum|unk@fixed|HEAD|MWE|TITLE|CONV]-> D1}
    without{ D -[1=comp|conj|expr|goeswith|reparandum|HEAD|MWE|TITLE|CONV]-> D1}
    without{D -[punct]-> D2; D -[punct]-> D1; D1.lemma = D2.lemma; D >> D1; D << D2}
    without{
      D -[punct]-> D2; D -[punct]-> D1; D1.lemma = ")"; D2.lemma = "(";
      D2 << D; D << D1}
    without{
      D -[punct]-> D2; D -[punct]-> D1; D1.lemma = "»"; D2.lemma = "«";
      D2 << D; D << D1}
    without{
      D -[punct]-> D2; D -[punct]-> D1; D1.lemma = "]"; D2.lemma = "[";
      D2 << D; D << D1}
    without{
      D -[punct]-> D2; D -[punct]-> D1; D2.lemma = ")"; D1.lemma = "(";
      D1 << D; D << D2}
    without{
      D -[punct]-> D2; D -[punct]-> D1; D1.lemma = "»"; D2.lemma = "«";
      D1 << D; D << D2}
    without{
      D -[punct]-> D2; D -[punct]-> D1; D1.lemma = "]"; D2.lemma = "[";
      D1 << D; D << D2}
    commands{add_edge e: H -> D1; del_edge e}
  }

  rule embedding_punct{
    pattern{
      H -[rev=y]-> D;
      e1: D -[punct]-> P1; P1 << D; P1 << H;
      e2: D -[punct]-> P2; P2 >> D; P2 >> H}
    without{P1[lemma="."|";"|":"|"\'"]}
    without{P2[lemma="."|";"|":"|"\'"]}
    without{P1.lemma = "("; P2.lemma <> ")"}
    without{P1.lemma = "«"; P2.lemma <> "»"}
    without{P1.lemma = "["; P2.lemma <> "]"}
    without{P1.lemma = "{"; P2.lemma <> "}"}
    commands{
      add_edge H -[punct]-> P1; del_edge e1;
      add_edge H -[punct]-> P2; del_edge e2}
  }

  rule conj{
    pattern{H -[rev=y]-> D; e:D -[1=conj]-> D1; D.upos <> D1.upos}
    without{D1 << H} %Ex : UD_French-GSD  fr-ud-train_14326
    without{D[upos=AUX]; D1[upos=VERB]; H >> D1}%Ex: UD_French-GSD fr-ud-train_06092
    without{D[upos=AUX]; D1[upos=VERB]; H1 -> D; H1 >> D1} %Ex: UD_French-GSD fr-ud-train_09763
    commands{add_edge e: H -> D1; del_edge e}
  }
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SUD relations with adpositions or conjonctions of subordination are renamed as case or mark UD relations.
package case_mark_relations {
% Nominal heads of relations with an adposition as its dependent.
% Ex: à Paris - comme à Paris - il ira plutôt à Lyon qu'à Paris.
  rule case_nom{
    pattern{ e:H -[1=comp,2=obj,rev=y]-> D; H[nom=y];D[upos=ADP|PART] }
    without{ H -[1=comp|mark]-> CONJ; CONJ[upos=CCONJ|SCONJ]; D << CONJ; CONJ << H}
    without{ H -[1=comp|mark]-> CONJ; CONJ[upos=CCONJ|SCONJ]; D >> CONJ; CONJ >> H}
    commands {e.1=case}
  }

% Nominal heads of relations with a conjunction and without adpositions as dependents.
% Ex: Lyon est plus près que Paris.
  rule case_nom_conj{
    pattern{ e:H -[1=comp,2=obj,rev=y]-> D; H[nom=y];D[upos=CCONJ|SCONJ] }
    without{H -> ADP; ADP[upos=ADP|PART]}
    commands {e.1=case}
  }

% Adjectival or adverbial heads of relations with an adposition and without conjunctions as dependents between the head and the adposition.
% Ex: dès demain - en continu
  rule case_pred{
    pattern{ e:H -[1=comp,2=obj,rev=y]-> D; H[upos=ADV|ADJ];D[upos=ADP|PART] }
    without{ H -[1=comp|mark]-> CONJ; CONJ[upos=CCONJ|SCONJ]; D << CONJ; CONJ << H}
    without{ H -[1=comp|mark]-> CONJ; CONJ[upos=CCONJ|SCONJ]; D >> CONJ; CONJ >> H}
    commands {e.1=case}
  }
  rule mark{
    pattern{ e:H -[1=comp,2=obj,rev=y]-> D; H[upos=AUX|VERB,!nom];D[upos=ADP|CCONJ|PART|SCONJ] }
    commands {e.1=mark}
  }

% si possible
  rule mark_pred_conj{
    pattern{ e:H -[1=comp,2=obj,rev=y]-> D; H[upos=ADJ|ADV,!nom];D[upos=CCONJ|SCONJ] }
    commands {e.1=mark}
  }

% Governors of an adposition, with a conjunction between the governor and the adposition.
% Ex: dès que possible
  rule mark_pred_adp1{
    pattern{
      e:H -[1=comp,2=obj,rev=y]-> D; D[upos=ADP|PART];
      H -[1=comp|mark]-> CONJ; CONJ[upos=CCONJ|SCONJ]; D << CONJ; CONJ << H}
    commands {e.1=mark}
  }

% Governors of an adposition, with a conjunction between the governor and the adposition.
  rule mark_pred_adp2{
    pattern{
      e:H -[1=comp,2=obj,rev=y]-> D; D[upos=ADP|PART];
      H -[1=comp|mark]-> CONJ; CONJ[upos=CCONJ|SCONJ]; D >> CONJ; CONJ >> H}
    commands {e.1=mark}
  }

% comme à Paris
  rule mark_nom1{
    pattern{
      e:H -[1=comp,2=obj,rev=y]-> D;
      H[nom=y];D[upos=CCONJ|SCONJ];
      H -[1=case]-> ADP; D << ADP; ADP << H}
    commands {e.1=mark}
  }

  rule mark_nom2{
    pattern{
      e:H -[1=comp,2=obj,rev=y]-> D;
      H[nom=y];D[upos=CCONJ|SCONJ];
      H -[1=case]-> ADP; D >> ADP; ADP >> H}
    commands {e.1=mark}
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% It is necessary to delete the reversed marks because there is another package reversing heads and it must start with no reversed marks.
package reverse_close {

  % if two conj are connected by a change of head, add the "emb" subtype
  rule connect_conj {
    pattern { H -[1=conj,rev=y]-> D; e:D -[conj]-> D1}
    commands { e.2 = emb }
  }

  rule del_reversed{
    pattern{e:H -[rev=y]-> D}
    without {H -[1=conj]-> D; D -[conj]-> D1; } % apply only if [connect_conj] cannot be applied
    commands {del_feat e.rev}
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SUD sub-relations  are renamed as UD relations or sub-relations.
% Rem: the rules are ordered according to the alphabetic order of the names of the resulting relations
package sub_relations {
  rule acl_relcl {
    pattern { e:H -[1=mod,deep=relcl]-> D }
    commands {e.1=acl}
  }

  rule advclcleft {
    pattern { e:H -[comp:cleft]-> D }
    commands {e.1=advcl; e.2=cleft}
  }

% All auxiliaries except tense auxiliaries.
  rule aux{
    pattern{ e:H -[1=comp,2=aux, !deep]-> D }
    commands {e.1=aux}
  }

  rule aux_deep{
    pattern{ e:H -[1=comp,2=aux,deep=*]-> D }
    commands {
      add_edge H -[1=aux, 2=e.deep]-> D;
      del_edge e;
    }
  }

% Complement that is a complete clause without control of its subject.
  rule ccomp {
    pattern {e:H -[1=comp, 2=obj|obl|pred]-> D; D[upos = AUX|VERB,!nom]}
    without{ H -[comp:obj@x|comp:obl@x|comp:pred@x]-> D}
    without {H -[comp:obj@pass|expl:pass]-> * } % if so csubj:pass XXX
    commands {e.1=ccomp}
  }

% Clausal complement  with a non-verbal head.
  rule ccomp_non-verb {
    pattern {
      e:H -[1=comp, 2=obj|obl]-> D; D[upos<> AUX|VERB];
      D -[1=mark]-> CONJ}
    commands {e.1=ccomp}
  }

  rule cop{
    pattern{ e:H -[1=comp,2=pred]-> D; H[upos=AUX]}
    commands {e.1=cop}
  }

  rule csubj {
    pattern { e:H -[comp:obj@agent]-> D; D[upos=AUX|VERB]}
    commands { del_edge e; add_edge H -[csubj]-> D }
  }

% In an impersonal active construction, the deep clausal subject, which is a COMP:OBJ dependent in SUD, becomes a CSUBJ dependent in UD.
% Ex: il m'arrive de faire des erreurs.
  rule csubj_expl{
    pattern { e:H -[comp:obj@expl]-> D; D[upos=AUX|VERB]}
    commands {e.1=csubj;e.2=expl; del_feat e.deep}
  }

% In an impersonal active construction, the deep clausal subject introduced with a conjunction, which is a COMP:OBJ dependent in SUD, becomes a CSUBJ dependent in UD.
% Ex: il m'arrive de faire des erreurs.
  rule csubj_expl_conj{
    pattern {
      e:H -[comp:obj@expl]-> D;D[upos <>AUX|VERB];
      D -[1=mark]-> CONJ}
    commands {e.1=csubj;e.2=expl; del_feat e.deep}
  }

% In an impersonal passive construction, the deep clausan subject, which is a COMP:OBJ dependent in SUD, becomes a CSUBJ:PASS dependent in UD.
% Ex: Il est prévu de continuer. - Il se dit que tu viendras.
  rule csubj_expl_pass{
    pattern { e:H -[comp:obj@pass]-> D; D[upos=AUX|VERB]}
    commands {e.1=csubj;e.2=pass; del_feat e.deep}
  }

  rule csubj_pass {
    pattern {e:H -[1=comp, 2=obj]-> D; D[upos = AUX|VERB,!nom]; H -[subj@expl|expl:subj]-> *; H -[comp@pass|expl:pass]-> * }
    commands {e.1=csubj; e.2=pass}
  }

  rule expl{
    pattern{ e:H -[unk@expl]-> D}
    commands {e.1=expl; del_feat e.deep}
  }

% An expletive complement, which is a COMP:EXPL dependent in SUD, becomes an EXPL:COMP dependent in UD.
% Ex: Les gens s'enfuient - Il s'agit d'un accident.
  rule expl_comp{
    pattern{ e:H -[comp@expl]-> D}
    commands {e.1=expl;e.2=comp; del_feat e.deep}
  }

% An expletive complement in a passive construction, which is a COMP:PASS dependent in SUD, becomes an EXPL:PASS dependent in UD.
% Ex:  Les voitures se vendent bien. - Il s'est vendu une grande maison aujourd'hui. -  Il se dit que tu viendras.
  rule expl_pass {
    pattern {e: H -[comp@pass]-> D}
    commands {del_edge e;add_edge H -[expl:pass]-> D}
  }

% In an impersonal construction, the impersonal subject, which is a SUBJ:EXPL dependent in SUD, becomes an  EXPL:SUBJ dependent in UD.
% Ex: Il arrive deux personnes. - Il faut un bilan. - Il s'agit d'une erreur. - Il a été vendu une grande maison. - il se dit que tu viendras.
  rule expl_subj{
    pattern{ e:H -[subj@expl]-> D}
    commands {e.1=expl;e.2=subj; del_feat e.deep}
  }

  rule fixed{
    pattern{ e:H -[unk@fixed]-> D}
    commands {e.1=fixed; del_feat e.deep}
  }

% iobj is used for any argument of a non-nominal governor, which is an adverb or a pronoun not introduced by a preposition 
  rule iobj {
    pattern {H[!nom]; e:H -[1=comp,2=obl]-> D; D[upos=ADV|PRON]}
    without{D -[case]-> *}
    commands {e.1=iobj}
  }

  rule nmod{
    pattern { e:H -[1=comp, 2=obl]-> D; H[nom=y]; D[nom=y];  }
    commands {e.1=nmod}
  }

  rule nmod_poss {
    pattern { e:H -[1=mod, 2=poss]-> A; A[upos=ADJ] }
    commands {e.1=nmod}
  }

  rule nsubj {
    pattern { e:H -[comp:obj@agent]-> D; D[nom=y]; H -[subj@expl|expl:subj]-> *}
    commands { del_edge e; add_edge H -[nsubj]-> D }
  }

% In an impersonal active construction, the deep nominal subject, which is a COMP:OBJ dependent in SUD, becomes a NSUBJ dependent in UD.
% Ex: il arrive deux personnes.
  rule nsubj_expl{
    pattern { e:H -[comp:obj@expl]-> D; D[nom=y]}
    without{ H -[comp@pass]-> AUX}
    without{D -[1=mark]-> CONJ}
    commands {e.1=nsubj; e.2=expl; del_feat e.deep}
  }

% In an impersonal passive construction, the deep nominal subject, which is a COMP:OBJ dependent in SUD, becomes a NSUBJ:PASS dependent in UD.
% Ex: Il a été vendu une grande maison. - Il s'est vendu une grande maison.
  rule nsubj_expl_pass{
    pattern { e:H -[comp:obj@pass]-> D; D[nom=y]; H -[expl:subj]-> S}
    commands {e.1=nsubj; e.2=pass; del_feat e.deep}
  }

% Impersonal subject with passive pronominal.
  rule nsubj_obj {
    pattern { e:H -[1=comp, 2=obj, !deep]-> D; D[nom=y]; H -[subj@expl|expl:subj]-> *; H -[comp@pass|expl:pass]-> *; }
    commands {e.1=nsubj}
  }

  % added for Naija
  rule nummod_det {
    pattern { e:H -[1=det, 2=num]-> D; }
    commands { e.1=nummod; e.2=det}
  }

  % added for Naija
  rule nummod_mod {
    pattern { e:H -[1=mod, 2=num]-> D; }
    commands { e.1=nummod; e.2=mod}
  }

  rule obj_agent {
    pattern { e:H -[comp:obj@agent]-> D}
    without{H -[subj@expl|expl:subj]-> *}
    commands {del_edge e; add_edge H -[obj:agent]-> D }
  }

   rule obj_lvc{
    pattern { e:H -[comp:obj@lvc]-> D}
    commands {del_edge e; add_edge H -[obj:lvc]-> D}
  }

   rule obj_nom{
    pattern { e:H -[1=comp, 2=obj, !deep]-> D; D[nom=y]}
    without{ H -[comp:obj@expl]-> D}
    without{ D -[1=mark]-> *}
    without { H -[subj@expl|expl:subj]-> *; H -[comp@pass|expl:pass]-> *; } % if so, the relation becomes subj (see rules nsubj_2/csubj_2)
    commands {e.1=obj}
  }

   rule obj_pred{
    pattern { e:H -[1=comp, 2=obj]-> D; D[cat=ADJ|ADV|INTJ,!nom]}
    without{ H -[comp:obj@expl]-> D}
    without{ D -[1=mark]-> *}
    commands {e.1=obj}
  }

  rule obl_agent {
    pattern { e:H -[1=comp,2=obl,deep=agent]-> D; D -[case]-> * }
    commands { e.1=obl; e.2=agent; del_feat e.deep }
  }

  rule obl_arg_nom {
    pattern { e:H -[1=comp,2=obl]-> D; H[upos=ADJ|ADV|AUX|INTJ|VERB]; D[upos <> ADV|PRON,nom=y] }
    without{ D -[1=mark]-> *}
    commands {e.1=obl; e.2=arg}
  }

  rule obl_arg {
    pattern { e:H -[1=comp,2=obl]-> D; H[upos=ADJ|ADV|AUX|INTJ|VERB]; D[upos=ADJ] }
    without{ D -[1=mark]-> *}
    commands {e.1=obl; e.2=arg}
  }

  rule obl_arg_adv-pron {
    pattern { e:H -[1=comp,2=obl]-> D; D[upos=ADV|PRON]; D -[1=case]-> * }
    commands {e.1=obl; e.2=arg}
  }

  rule xcomp {
    pattern { e:H -[comp:obj@x|comp:obl@x|comp:pred@x|comp:pred|comp:pred@lvc]-> D }
    without{ H[upos=AUX]}
    without{ D[upos=AUX|VERB]; H -[comp:pred]-> D}
    commands {e.1=xcomp; del_feat e.2; del_feat e.deep}
  }

   rule xcomp_lvc{
    pattern { e:H -[comp:pred@lvc]-> D}
    commands {del_edge e; add_edge H -[xcomp:lvc]-> D}
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SUD deep extensions of relations are transformed into  extensions of UD relations
package rel_extensions {
  rule change_ext{
    pattern{e: H -[1=*, deep <> fixed]-> D}
    commands{ add_edge H -[1=e.1,2=e.deep]-> D; del_edge e}
  }

  rule del_ext{
    pattern{e: H -[1=*,2=aux|emb|obj|obl|pred,!deep]-> D}
    commands{del_feat e.2}
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SUD relations are renamed as UD relations or sub-relations.
% Rem: the rules are ordered according to the alphabetic order of the names of the resulting relations
package relations {

% A nominal governs a participle or an infinitive in a MOD relation.
  rule acl_part {
    pattern {
      e:H -[1=mod]-> D; H[nom=y];
      D[upos=AUX|VERB,!nom, VerbForm=Inf|Part]
    }
    without{D -[1=mark]-> *}
    without{D -[1=aux]-> AUX; AUX[VerbForm=Fin]}
    without{PRO[PronType=Rel]; D -> PRO; PRO << D; H << PRO}
    without{PRO[PronType=Rel]; D -> X; X -> PRO; PRO << D; H << PRO}
    commands {e.1=acl}
  }

%  A nominal governs the head of a complementized clause in a UDEP relation.
  rule acl_mark-clause {
    pattern {
      e:H -[1=mod|udep]-> D; H[nom=y];
      D -[1=mark]-> *
    }
    commands {e.1=acl}
  }

%  A nominal governs a finite verb in a MOD relation and the hypothesis is that this verb is always the head of a relative clause.
  rule aclrel {
    pattern {
      e:H -[1=mod]-> D; H[upos <> AUX|VERB];
     % H[nom=y]; H can be an adverb
      D[upos=AUX|VERB,VerbForm=Fin]  }
    without { D -[1=mark]-> X}
    commands {e.1=acl; e.2=relcl}
  }


% A word H has a modifier D, which is not a finite verb and itself governs a relative pronoun and the relative pronoun is located between H and D. The hypothesis is that D is  the head of a relative clause.
  rule aclrel_relpro1{
    pattern{
      e: H -[1=mod]-> D; H[upos <> AUX|VERB];
      D -> PRO; H << PRO; PRO << D; PRO[PronType=Rel]
    }
    without{D[upos=AUX|VERB,VerbForm=Fin]}
    commands {e.1=acl; e.2=relcl}
  }

% A word H has a modifier D, which is not a finite verb and itself indirectly governs a relative pronoun via an intermediate word and the relative pronoun is located between H and D. The hypothesis is that D is  the head of a relative clause.
  rule aclrel_relpro2{
    pattern{
      e: H -[1=mod]-> D;  H[upos <> AUX|VERB];
      D -> X; X -> PRO; H << PRO; PRO << D; PRO[PronType=Rel]
    }
    without{D[upos=AUX|VERB,VerbForm=Fin]}
    commands {e.1=acl; e.2=relcl}
  }

  rule advcl {
    pattern { H[!nom]; e:H -[1=mod]-> D; D[upos=ADJ|AUX|VERB,!nom] }
    without{H[upos=ADJ|NUM];D[upos=ADJ]}
    without {D[upos=ADJ]; D -[1=case]-> X}
    without{ PRO[PronType=Rel]; D -> PRO; H << PRO; H [upos <> AUX|VERB]} % The dependency MOD is not the dependency of a relative clause.
    commands {e.1=advcl}
  }

% Ex: fr-ud-train_01058 - Son équipe en difficulté, il est remplacé à la mi-temps ...
% Ex: fr-ud-dev_00890 - ... les restes du château d'Eaucourt étaient plus considérables qu'aujourd'hui.
% Ex: fr-ud-test_00158 - Comme chaque soir à 18h40, il tranche, malmène et détourne l'actualité.
  rule advcl_ellipsis {
    pattern {H[!nom]; e:H -[1=mod]-> D; D -[1=mark|nsubj]-> X }
    without{D[upos=VERB]}
    commands {e.1=advcl}
  }

  rule advmod {
    pattern { e:H -[1=mod]-> D; D[upos=ADV|CCONJ|INTJ|PART|SYM, !nom] }
    without{D -[1=mark]-> X}
    commands {e.1=advmod}
  }

  rule advmod2 {
    pattern { e:H -[1=udep]-> D; H [nom=y]; D[upos=ADV, !nom] }
    without{D -[1=mark]-> X}
    commands {e.1=advmod}
  }

  rule amod1 {
    pattern { H[upos=ADJ|NUM]; e:H -[1=mod]-> D; D[upos=ADJ] }
    without{ D -[1=mark]-> X}
    without{ PRO[PronType=Rel]; D -> PRO; H << PRO}
    commands {e.1=amod}
  }

  rule amod2 {
    pattern { H[nom=y]; e:H -[1=mod]-> D; D[upos=ADJ] }
    without{ D -[1=mark]-> X}
    without{ PRO[PronType=Rel]; D -> PRO; H << PRO}
    commands {e.1=amod}
  }

% Clausal subject.
  rule csubj {
    pattern { e:V -[1=subj]-> S; S[upos=AUX|VERB, !nom] }
   % without { V -[aux:pass]-> * }
    commands {e.1=csubj}
  }

  rule dep{
    pattern{ e: H -[unk]-> D}
    commands{e.1=dep}
  }

% When a determiner relation has a numeral as its dependent, it is labelled with NUMMOD.
  rule det_nummod{
    pattern { e: H -[1=det]-> D; D[upos=NUM] }
    commands {e.1=nummod}
  }

  rule nmod {
    pattern {e:H -[1=mod|udep]-> D; H[nom=y]; D[nom=y]}
    without{D -[1=mark]-> X}
    without{ PRO[PronType =Rel]; D -> PRO; H << PRO; PRO << D} % D cannot be the head of relative clause, H being the antecedent of this clause.
    commands {e.1=nmod}
  }

% A nominal governs an adjective introduced with an adposition in a DEP_SUD relation.
  rule nmod_adj {
    pattern {e:H -[1=udep]-> D; H[nom=y]; D[upos=ADJ]; D -[1=case]-> X}
    without{D -[1=mark]-> Y}
    commands {e.1=nmod}
  }

  rule nmod_num1{
    pattern {e:H -[1=mod]-> D; H[upos=NUM]; D[upos=NUM]}
    commands {e.1=nmod}
  }

% A numeral is dependent on another numeral via an adposition.
  rule nmod_num2{
    pattern {
      N1[upos=NUM]; N2[upos=NUM]; e:N1 -[1=udep]-> N2;
      N2 -[1=case]-> P}
    commands {e.1=nmod}
  }

% A numeral is a modifier of an nominal that has a case marker between it and the numaral.
  rule nmod_num3{
    pattern {
      N1[nom=y]; N2[upos=NUM]; e:N1 -[1=mod]-> N2;
      N1 -[case]-> ADP; N2 << ADP; ADP << N1}
    commands {e.1=nmod}
  }

% Nomminal subject.
  rule nsubj {
    pattern { e:V -[1=subj]-> S; S[nom=y] }
    commands {e.1=nsubj}
  }

  rule nummod {
    pattern { e:H -[1=mod]-> D; D[upos=NUM]; D << H }
    without{ PRO[PronType=Rel]; D -> PRO; H << PRO}
    without{ H -[1=case|mark]-> D1; D << D1}
    without{ D -[case|mark]-> *}
    commands {e.1=nummod}
  }

  rule oblmod {
    pattern { H[!nom]; e:H -[1=mod]-> D; D[nom=y] }
    without{ D -[1=nsubj|mark|subj]-> X}
    without{H[upos=NUM];D[upos=NUM]}
    commands {e.1=obl; e.2=mod}
  }

  rule oblmod_adj {
    pattern { H[!nom]; e:H -[1=mod]-> D; D[upos=ADJ,!nom]; D -[1=case]-> X }
    commands {e.1=obl; e.2=mod}
  }

% A predicate governs a nominal or an adjective in a DEP_SUD relation.
  rule obl {
    pattern {e:H -[1=udep]-> D; H[upos=ADJ|ADV|VERB|AUX|INTJ,!nom]}
    without{D[upos <> ADJ|ADV, !nom]}
    commands {e.1=obl}
  }
}

rule relations_backoff {
  pattern { e:H -[1=unk|subj|udep|mod|comp]-> D; }
  commands { del_edge e; add_edge H -[dep]-> D; }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The relations with auxiliaries as their heads are reversed.
package reverse_aux {

  rule rev_head {
    pattern {e:H -[1=aux|cop,!rev]-> D; H[upos= AUX]}
    without{D[upos= AUX]; D -[1=aux|cop,!rev]-> D1}
    commands {
      e.rev=y;
      add_edge e:D -> H;
      del_edge e;
      shift_in H =[^MWE|TITLE]=> D;
 %     shift_out H =[^conj|conj:dicto|expr|goeswith|reparandum|unk@fixed|MWE|TITLE]=> D;
    }
  }
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package final {
  rule del_nom{
    pattern {W[nom=y]}
    commands {del_feat W.nom}
  }

  rule rm_emb {
    pattern { e:M -[conj:emb]-> N }
    commands { del_edge e; add_edge M -[conj]-> N }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
strat main {
  Seq (
    Onf (remove_deep_fixed), % in UD, @fixed becomes INMWE
    Onf(shared), % Package SHARED must precede SPECIFIC_EXPR_INIT so that feature Shared=Yes is not embedded in MWE.
    specific_expr_init, % Initialization of a specific treatment for MWE, titles and translated words.
    Onf (nom_init),
    Onf (unchained_relations), % For CONJ relations, chains must be transformed into bouquets before head changes because of conditions on the presence of prepositions, conjunctions and auxiliaries. It is easier to take these conditions into account before head changes (UD_French-GSD : fr-ud-dev_00751)
    Onf (reverse_case_mark),  % Package REVERSE_CASE_MARK precedes packages SUB_RELATIONS and RELATIONS because  UD labels of complement relations depend on the category of the complements introduced with a preposition or a conjunction
    Onf(shift_out_edges),
    Onf(case_mark_relations), %Package CASE_MARK_RELATIONS must precede package SUB_RELATIONS because renaming of some SUD relations requires the distinction between case and mark relations. The package must also precede package REVERSE_CLOSE because changes concern only reversed relations (Counter-example : SUD_French-GSD fr-ud-train_03238
    Onf( reverse_close),
    Onf (sub_relations), % Package SUB_RELATIONS must precede package REL_EXTENSIONS because this package swat extensions on level 2.
    Onf (rel_extensions),
    Onf (relations),
    Onf (relations_backoff),
    Onf(reverse_aux),    % Package REVERSE_AUX follows packages SUB_RELATIONS and RELATIONS because of the dependencies H -> AUX in UD: if H is the target of a dependency, the label of the dependency may depend on the mood of AUX.
    Onf(shift_out_edges),
    Onf( reverse_close),
    Onf (final),
    specific_expr_close, % Closing a specific treatment for MWE, titles and translated words.
  )
}
