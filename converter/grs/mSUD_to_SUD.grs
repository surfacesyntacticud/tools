%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
strat mSUD_to_SUD_main { 
  Seq (
    % Onf (up_type_m),
    Onf (init),
    Onf (fusion),
    Onf (final),
  )
}

package init {
  % Three next rules unify potential DerPos and CpdPos into one unique name "FinalPos" for uniform rule later
  rule DerPos {
    pattern { X [DerPos] }
    commands { X.FinalPos=X.DerPos; del_feat X.DerPos }
  }
  rule CpdPos {
    pattern { X [CpdPos] }
    commands { X.FinalPos=X.CpdPos; del_feat X.CpdPos }
  }

  rule NoPosChange {
    pattern { X [upos, !CpdPos, !DerPos, !FinalPos] }
    commands { X.FinalPos=X.upos }
  }

  % replace no_lemma by empty lemma for uniform rules later
  % no_lemma is restored in final package
  rule empty_lemma {
    pattern { X [upos, !lemma]}
    commands { X.lemma = "" }
  }
}


package fusion {
  % The rule [up_type_m] ensures that there is word-level dependency above a morph-level dependency
  % If such a pattern in found, the relation goes up in the tree
  % WARNING: may have unexpected effect if a /m is missing (cf Pesh)
  rule up_type_m {
    pattern { 
      N1 -[type=m]-> N2;
      e: N2 -[!type]-> N3;
    }
    commands {
      add_edge f:N1 -> N3;
      f.label = e.label;
      del_edge e
    }
  }

  rule suff_fusion {
    pattern {
      N[]; M[];
      N -[type=m]-> M;                                    % M is attached with the /m extension
      N < M                                                % M is a suffix
    }
    without { M -> * }                                     % M is a leaf (force application order)
    commands { 
      N.form = N.form + M.form;                            % concatenate the surface form
      N.wordform = N.wordform + M.wordform;                % concatenate the surface form
      N.lemma = N.lemma + M.lemma;                         % concatenate the surface lemma
      append_feats "_" M =[re"Translit\|Tone"]=> N;        % concatenate the surface Translit and Tone
      N.upos = N.FinalPos; 
      del_node M;
    }
  }
  
  rule pref_fusion {
    pattern {
      N[]; M[];
      N -[type=m]-> M;                                     % M is attached with the /m extension
      M < N                                                % M is a prefix
    }
    without { M -> * }                                     % M is a leaf (force application order)
    commands { 
      N.form = M.form + N.form;                            % concatenate the surface form
      N.wordform = M.wordform + N.wordform;                % concatenate the surface form
      N.lemma = M.lemma + N.lemma;                         % concatenate the surface lemma
      prepend_feats "_" M =[re"Translit\|Tone"]=> N;       % concatenate the surface Translit and Tone
      del_node M;
      N.upos = N.FinalPos; 
    }
  }

  rule missing_m_pref_fwd {
    pattern { X[form=re".+-"]; Y[]; X < Y; e: X -[!type]-> Y; }
    commands { e.type=m }
  }
  rule missing_m_pref_bck {
    pattern { X[form=re".+-"]; Y[]; X < Y; e: Y -[!type]-> X; }
    commands { e.type=m }
  }
  rule missing_m_suff_fwd {
    pattern { X[]; Y[form = re"-.+"]; X < Y; e: X -[!type]-> Y; }
    commands { e.type=m }
  }
  rule missing_m_suff_bck {
    pattern { X[]; Y[form = re"-.+"]; X < Y; e: Y -[!type]-> X; }
    commands { e.type=m }
  }
}

package final {
  rule clean_final_pos {
    pattern { X [FinalPos] }
    commands { del_feat X.FinalPos }
  }

  % restore no_lemma
  rule empty_lemma {
    pattern { X [lemma= ""]}
    commands { del_feat X.lemma }
  }
}

