%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
strat zh_mSUD_to_SUD_main { 
  Seq (
    Onf (fusion)
  )
}

% TODO :
% convert xpos to DerPos

package fusion {
  rule suff_fusion_extpos {
    pattern {
      N [xpos];
      N -[morph=m]-> M;                                    % M is attached with the :m extension
      N < M                                                % M is a suffix
    }  
    without { M -> X}                                      % M is a leaf (force application order)
    commands { 
      N.form = N.form + M.form;                            % concatenate the surface form
      N.wordform = N.wordform + M.wordform;                % concatenate the surface form
      N.lemma = N.lemma + M.lemma;                         % concatenate the surface lemma
      N.Translit = N.Translit + "_" + M.Translit;          % concatenate the surface Translit
      N.Tone = N.Tone + "_" + M.Tone;                      % concatenate the surface Tone
      del_node M;
      N.upos = N.xpos; del_feat N.xpos;
    }
  }

  rule suff_fusion {
    pattern {
      N[!xpos];
      N -[morph=m]-> M;                                    % M is attached with the :m extension
      N < M                                                % M is a suffix
    }  
    without { M -> X}                                      % M is a leaf (force application order)
    commands { 
      N.form = N.form + M.form;                            % concatenate the surface form
      N.wordform = N.wordform + M.wordform;                % concatenate the surface form
      N.lemma = N.lemma + M.lemma;                         % concatenate the surface lemma
      N.Translit = N.Translit + "_" + M.Translit;          % concatenate the surface Translit
      N.Tone = N.Tone + "_" + M.Tone;                      % concatenate the surface Tone
      del_node M;                                          % concatenate the surface form
    }
  }
  
  rule pref_fusion_extpos {
    pattern {
      N [xpos];
      N -[morph=m]-> M;                                    % M is attached with the :m extension
      M < N                                                % M is a prefix
    }  
    without { M -> X}                                      % M is a leaf (force application order)
    commands { 
      N.form = M.form + N.form;                            % concatenate the surface form
      N.wordform = M.wordform + N.wordform;                % concatenate the surface form
      N.lemma = M.lemma + N.lemma;                         % concatenate the surface lemma
      N.Translit = M.Translit + "_" + N.Translit;          % concatenate the surface Translit
      N.Tone = M.Tone + "_" + N.Tone;                      % concatenate the surface Tone
      del_node M;
      N.upos = N.xpos; del_feat N.xpos;
    }
  }

  rule pref_fusion {
    pattern { 
      N [!xpos];
      N -[morph=m]-> M;                                    % M is attached with the :m extension
      M < N                                                % M is a prefix
    }  
    without { M -> X}                                      % M is a leaf (force application order)
    commands { 
      N.form = M.form + N.form;                            % concatenate the surface form
      N.wordform = M.wordform + N.wordform;                % concatenate the surface form
      N.lemma = M.lemma + N.lemma;                         % concatenate the surface lemma
      N.Translit = M.Translit + "_" + N.Translit;          % concatenate the surface Translit
      N.Tone = M.Tone + "_" + N.Tone;                      % concatenate the surface Tone
      del_node M;                                          % concatenate the surface form
    }
  }
}

