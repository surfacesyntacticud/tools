include "mSUD_to_SUD.grs"

strat yrk_mSUD_to_SUD_main {
	Seq (
		Onf(yrk_pre),
		Onf(init_MGloss_MSeg),
		mSUD_to_SUD_main,
		Onf(final_MGloss_MSeg),
	)
}

% Put MGloss/MGseg on all node
rule init_MGloss_MSeg {
	pattern {
		X[upos, Gloss, !MGloss, !Mseg]
	}
  commands {
    X.MGloss = X.Gloss;
    X.MSeg = X.form;
  }
}

package final_MGloss_MSeg {
  rule rm_MGloss {
    pattern { X[Gloss, MGloss]; X.Gloss = X.MGloss }
		commands { del_feat X.MGloss }
	}
  rule rm_Gloss {
    pattern { X[Gloss, MGloss]; X.Gloss <> X.MGloss }
		commands { del_feat X.Gloss }
	}
  rule MSeg {
    pattern { X[form, MSeg]; X.form = X.MSeg }
		commands { del_feat X.MSeg }
	}
}

package yrk_pre {
	rule noise {
		pattern { e: X -[noise]-> Y }
		commands {
			e.label = punct;
			Y.upos=PUNCT;
		}
	}

	rule comp {
		pattern { e: X -[comp]-> Y }
		commands {
			e.label = "comp:obj";
		}
	}

	rule double_hyphen {
		pattern { X1 [form=re".*-"]; X2 [form=re"-.*"]; X1 < X2 }
		commands {
			X1.form = X1.form[:-1];
			X1.wordform = X1.form;
		}
	}

	rule hack_8_61 {
		global {sent_id = "yrk_PearStory_8"|"yrk_PearStory_61" }
		pattern { f: H -[comp:aux]-> V ; e:H -[1=subj]-> P }
		commands {
			del_edge e;
			add_edge V -[subj]-> P;
			f.type=m;
		 }
	}

	rule hack_42 {
		global {sent_id = "yrk_PearStory_42" }
		pattern { e: X -[comp:obj]-> Y ;  }
		commands {
			e.type=m;
		}
	}

	rule lemma_X {
		pattern { X [lemma=X, form=re"-.*"] }
		commands {
			X.lemma ="";
		}
	}
}
