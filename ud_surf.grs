package chained_conj {
  rule r {
    pattern {
      H -[conj]-> X1;
      e: H -[conj]-> X2;
      X1 << X2;
    }
    without {
      H -[conj]-> X;
      X1 << X; X << X2;
    }
    without {
      H -[conj]-> X;
      X2 << X;
    }
    commands {
      del_edge e;
      add_edge X1 -[conj]-> X2;
    }
  }
}

package case_dep{
	rule r{
		pattern {
		e:H-[case]->X1;
		}

		commands {
		del_edge e;
		add_edge X1-[dep]-> H;
		shift_in H==>X1;
		shift_out H=[punct|cc|conj]=>X1;
		}

	}
}

package amalgam {
  rule amalgam (feature $prep, $det, $amalgam) {
    pattern {
      P [cat=PREP, phon= $prep];
      D [cat=DET, phon= $det];
      P < D;
    }
    commands {
      del_node D;
      P.phon = $amalgam;
      % The two next commands are needed to ensure correct CoNLLU output (without the x-y line for amalgam)
      del_feat P._UD_mw_fusion;
      del_feat P._UD_mw_span;
    }
  }
#BEGIN
à#le#au
à#les#aux
#END
}

package amalgam_file {
  rule amalgam (feature $prep, $det, $amalgam; file "lexicons/amal.lex") {
    pattern {
      P [cat=PREP, phon= $prep];
      D [cat=DET, phon= $det];
      P < D;
    }
    commands {
      del_node D;
      P.phon = $amalgam;
      % The two next commands are needed to ensure correct CoNLLU output (without the x-y line for amalgam)
      del_feat P._UD_mw_fusion;
      del_feat P._UD_mw_span;
    }
  }
}



strat main { Seq(
  Onf (chained_conj),
  Onf (case_dep),
  Onf (amalgam_file),
)
}
