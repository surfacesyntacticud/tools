package UDPOS_init {
  rule case {
    pattern { X -[case]-> Y }
    without { Y [upos=ADP|PART] }
    without { Y [_MISC_MWEPOS=ADP|PART] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = ADP} % real value should be "ADP|PART"
  }

  rule mark {
    pattern { X -[mark]-> Y }
    without { Y [upos=ADP|SCONJ] }
    without { Y [_MISC_MWEPOS=ADP|SCONJ] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = ADP} % real value should be "ADP|SCONJ"
  }

  rule cop {
    pattern { X -[cop]-> Y }
    without { Y [upos=AUX] }
    without { Y [_MISC_MWEPOS=AUX] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = AUX}
  }

  rule aux {
    pattern { X -[re"aux.*"]-> Y }
    without { Y [upos=AUX] }
    without { Y [_MISC_MWEPOS=AUX] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = AUX}
  }
}

package UDPOS_after_reverse {
  rule amod {
    pattern { X -[amod]-> Y }
    without { Y [upos=ADJ] }
    without { Y [_MISC_MWEPOS=ADJ] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = ADJ}
  }

  rule advmod {
    pattern { X -[advmod]-> Y }
    without { Y [upos=ADV] }
    without { Y [_MISC_MWEPOS=ADV] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = ADV}
  }

  rule nsubj {
    pattern { X -[re"nsubj.*"]-> Y }
    without { Y [upos=NOUN|PROPN|PRON] }
    without { Y [_MISC_MWEPOS=NOUN|PROPN|PRON] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = NOUN}
  }

  rule csubj {
    pattern { X -[re"csubj.*"]-> Y }
    without { Y [upos=VERB] }
    without { Y [_MISC_MWEPOS=VERB] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = VERB}
  }

  rule acl_advcl {
    pattern { X -[acl|advcl]-> Y }
    without { Y [upos=VERB|ADJ] }
    without { Y [_MISC_MWEPOS=VERB|ADJ] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = VERB} % real value should be "VERB|ADJ"
  }
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package chained_relations {
  rule conj {
    pattern {
      H -[conj]-> X1;
      e: H -[conj]-> X2;
      X1 << X2;
    }
    without {
      H -[conj]-> X;
      X1 << X; X << X2;
    }
    without {
      H -[conj]-> X;
      X2 << X;
    }
    commands {
      del_edge e;
      add_edge X1 -[conj]-> X2;
    }
  }

  rule fixed {
    pattern {
      H -[fixed]-> X1;
      e: H -[fixed]-> X2;
      X1 << X2;
    }
    without {
      H -[fixed]-> X;
      X1 << X; X << X2;
    }
    without {
      H -[fixed]-> X;
      X2 << X;
    }
    commands {
      del_edge e;
      add_edge X1 -[fixed]-> X2;
    }
  }

  rule flat_name {
    pattern {
      H -[flat:name]-> X1;
      e: H -[flat:name]-> X2;
      X1 << X2;
    }
    without {
      H -[flat:name]-> X;
      X1 << X; X << X2;
    }
    without {
      H -[flat:name]-> X;
      X2 << X;
    }
    commands {
      del_edge e;
      add_edge X1 -[flat:name]-> X2;
    }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package neg {
  rule r {
    pattern { e:V -[advmod]-> A; A[Polarity=Neg] }
    commands { del_edge e; add_edge V -[advmod:neg]-> A; }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package reverse {
  rule aux_left {
    pattern {
      V []; AUX [];
      e:V -[aux]-> AUX; AUX << V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop|mark|case]-> AUX2;
      AUX << AUX2; AUX2 << V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:aux]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|mark|case]=> AUX;
      shift_out V =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|conj|cc|punct|root]=> AUX;
    }
  }

  rule cop_left {
    pattern {
      V []; AUX [];
      e:V -[cop]-> AUX; AUX << V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop|mark|case]-> AUX2;
      AUX << AUX2; AUX2 << V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:cop]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|mark|case]=> AUX;
      shift_out V =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|conj|cc|punct|root]=> AUX;
    }
  }

  rule auxpass_left {
    pattern {
      V []; AUX [];
      e:V -[aux:pass]-> AUX; AUX << V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop|mark|case]-> AUX2;
      AUX << AUX2; AUX2 << V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:pass]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|mark|case]=> AUX;
      shift_out V =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|conj|cc|punct|root]=> AUX;
    }
  }

  rule auxcaus_left {
    pattern {
      V []; AUX [];
      e:V -[aux:caus]-> AUX; AUX << V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop|mark|case]-> AUX2;
      AUX << AUX2; AUX2 << V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:caus]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|mark|case]=> AUX;
      shift_out V =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|conj|cc|punct|root]=> AUX;
    }
  }

  rule aux_right {
    pattern {
      V []; AUX [];
      e:V -[aux]-> AUX; V << AUX;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop|mark|case]-> AUX2;
      V << AUX2; AUX2 << AUX;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:aux]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|mark|case]=> AUX;
      shift_out V =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|conj|cc|punct|root]=> AUX;
    }
  }

  rule cop_right {
    pattern {
      V []; AUX [];
      e:V -[cop]-> AUX; V << AUX;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop|mark|case]-> AUX2;
      V << AUX2; AUX2 << AUX;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:cop]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|mark|case]=> AUX;
      shift_out V =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|conj|cc|punct|root]=> AUX;
    }
  }

  rule auxpass_right {
    pattern {
      V []; AUX [];
      e:V -[aux:pass]-> AUX; V << AUX;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop|mark|case]-> AUX2;
      V << AUX2; AUX2 << AUX;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:pass]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|mark|case]=> AUX;
      shift_out V =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|conj|cc|punct|root]=> AUX;
    }
  }

  rule auxcaus_right {
    pattern {
      V []; AUX [];
      e:V -[aux:caus]-> AUX; V << AUX;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop|mark|case]-> AUX2;
      V << AUX2; AUX2 << AUX;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:caus]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|mark|case]=> AUX;
      shift_out V =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|conj|cc|punct|root]=> AUX;
    }
  }

  rule left_case{
    pattern { e:H-[case]->X1; X1 << H; }
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 << X2 }
    commands {
    del_edge e;
    add_edge X1-[comp]-> H;
    shift_in H==>X1;
    shift_out H =[aux|aux:pass|aux:caus|cop|mark|case]=> X1;
    shift_out H =[conj|cc|root]=> X1;
    }
  }

  rule left_mark{
    pattern { e:H-[mark]->X1; X1 << H }
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 << X2 }
    commands {
    del_edge e;
    add_edge X1-[comp]-> H;
    shift_in H==>X1;
    shift_out H =[aux|aux:pass|aux:caus|cop|mark|case]=> X1;
    shift_out H =[conj|cc|root]=> X1;
    }
  }

  rule right_case{
    pattern { e:H-[case]->X1; H << X1; }
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X2 << X1 }
    commands {
    del_edge e;
    add_edge X1-[comp]-> H;
    shift_in H==>X1;
    shift_out H =[aux|aux:pass|aux:caus|cop|mark|case]=> X1;
    shift_out H =[conj|cc|root]=> X1;
    }
  }

  rule right_mark{
    pattern { e:H-[mark]->X1; H << X1; }
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X2 << X1 }
    commands {
    del_edge e;
    add_edge X1-[comp]-> H;
    shift_in H==>X1;
    shift_out H =[aux|aux:pass|aux:caus|cop|mark|case]=> X1;
    shift_out H =[conj|cc|root]=> X1;
    }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  rule nummod_det {
    pattern { e:M -[nummod]-> N; }
    without { M -[det]-> *}
    without { M[cat=ADJ]; * -[amod|mod]-> M}
    commands { del_edge e; add_edge M -[det]-> N }
  }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package relations {
  rule ccomp_comp_obl {
    pattern { e:M -[obj|ccomp]-> N; N[cat = ADP]; }
    commands { del_edge e; add_edge M -[comp:obl]-> N }
  }
  rule comp_agent {
    pattern { e:M -[obl:agent]-> N; }
    commands { del_edge e; add_edge M -[comp:agent]-> N }
  }
  rule comp_cleft {
    pattern { e:M -[advcl:cleft]-> N; }
    commands { del_edge e; add_edge M -[comp:cleft]-> N }
  }
  rule comp_lvc {
    pattern { e:M -[obj:lvc]-> N; }
    commands { del_edge e; add_edge M -[comp:lvc]-> N }
  }
  rule comp_obj {
    pattern { e:M -[obj|ccomp]-> N; N[cat <> ADP]; }
    commands { del_edge e; add_edge M -[comp:obj]-> N }
  }
  rule comp_obj_caus {
    pattern { e:M -[obj:agent]-> N; }
    commands { del_edge e; add_edge M -[comp:obj]-> N }
  }
  rule comp_obl {
    pattern { e:M -[obl:arg|iobj]-> N; }
    commands { del_edge e; add_edge M -[comp:obl]-> N }
  }
  rule comp_rais {
    pattern { e:M -[xcomp]-> N; }
    commands { del_edge e; add_edge M -[comp:rais]-> N }
  }
  rule dep_obl { % in GSD, obl are not all subtyped
    pattern { e:M -[obl]-> N; }
    commands { del_edge e; add_edge M -[dep_SUD]-> N }
  }
  rule mod {
    pattern { e:M -[advmod|advmod:neg|advcl|obl:mod]-> N; }
    commands { del_edge e; add_edge M -[mod]-> N }
  }
  rule subj {
    pattern { e:M -[nsubj|nsubj:pass|csubj|csubj:pass]-> N; }
    commands { del_edge e; add_edge M -[subj]-> N }
  }
  rule nmod_dep {
    pattern { e:M -[acl|acl:relcl|amod|nmod|nummod]-> N; M [cat=SYM|NUM|NOUN|PRON|PROPN]}
    commands { del_edge e; add_edge M -[dep_SUD]-> N }
  }

% backoff rule
%  rule nmod_mod {
%    pattern { e:M -[acl|acl:relcl|amod|nmod|nummod]-> N; M [cat<>SYM|NUM|NOUN|PRON|PROPN]}
%    commands { del_edge e; add_edge M -[mod]-> N }
%  }



}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package raise_gov{
  rule raise_mod{
    pattern {
      G -> D; D >> G; MOD << G;
      mod_rel:D -[mod]-> MOD
    }
%    without { MOD [lemma = "où"]}  French specificity
    commands {
      del_edge mod_rel;
      add_edge G -[mod]-> MOD
    }
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package fail_label{

  rule FAIL_acl{
    pattern{e: G -[acl]-> D}
    commands{del_edge e; add_edge G -[FAIL_acl]-> D}
  }

  rule FAIL_advcl{
    pattern{e: G -[advcl]-> D}
    commands{del_edge e; add_edge G -[FAIL_advcl]-> D}
  }

  rule FAIL_advmod{
    pattern{e: G -[advmod]-> D}
    commands{del_edge e; add_edge G -[FAIL_advmod]-> D}
  }

  rule FAIL_amod{
    pattern{e: G -[amod]-> D}
    commands{del_edge e; add_edge G -[FAIL_amod]-> D}
  }

  rule FAIL_aux{
    pattern{e: G -[aux]-> D}
    commands{del_edge e; add_edge G -[FAIL_aux]-> D}
  }

  rule FAIL_case{
    pattern{e: G -[case]-> D}
    commands{del_edge e; add_edge G -[FAIL_case]-> D}
  }

  rule FAIL_ccomp{
    pattern{e: G -[ccomp]-> D}
    commands{del_edge e; add_edge G -[FAIL_ccomp]-> D}
  }

  rule FAIL_cop{
    pattern{e: G -[cop]-> D}
    commands{del_edge e; add_edge G -[FAIL_cop]-> D}
  }

  rule FAIL_csubj{
    pattern{e: G -[csubj]-> D}
    commands{del_edge e; add_edge G -[FAIL_csubj]-> D}
  }

  rule FAIL_iobj{
    pattern{e: G -[iobj]-> D}
    commands{del_edge e; add_edge G -[FAIL_iobj]-> D}
  }

  rule FAIL_mark{
    pattern{e: G -[mark]-> D}
    commands{del_edge e; add_edge G -[FAIL_mark]-> D}
  }

  rule FAIL_nmod{
    pattern{e: G -[nmod]-> D}
    commands{del_edge e; add_edge G -[FAIL_nmod]-> D}
  }

  rule FAIL_nsubj{
    pattern{e: G -[nsubj]-> D}
    commands{del_edge e; add_edge G -[FAIL_nsubj]-> D}
  }

  rule FAIL_nummod{
    pattern{e: G -[nummod]-> D}
    commands{del_edge e; add_edge G -[FAIL_nummod]-> D}
  }

  rule FAIL_obj{
    pattern{e: G -[obj]-> D}
    commands{del_edge e; add_edge G -[FAIL_obj]-> D}
  }

  rule FAIL_obl{
    pattern{e: G -[obl]-> D}
    commands{del_edge e; add_edge G -[FAIL_obl]-> D}
  }

  rule FAIL_xcomp{
    pattern{e: G -[xcomp]-> D}
    commands{del_edge e; add_edge G -[FAIL_xcomp]-> D}
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package amalgam {
  rule prep_det (feature $prep, $det, $amalgam) {
    pattern {
      P [cat=ADP, phon= $prep];
      D [cat=DET, phon= $det];
      P < D;
    }
    commands {
      del_node D;
      P.phon = $amalgam;
      % The three next commands are needed to ensure correct CoNLLU output (without the x-y line for amalgam)
      del_feat P._UD_mw_fusion;
      del_feat P._UD_mw_span;
      del_feat P._UD_MISC_SpaceAfter;
    }
  }
#BEGIN
à#le#au
à#les#aux
de#le#du
de#les#des
#END

  rule prep_pro (feature $prep, $pron, $amalgam) {
    pattern {
      PREP [cat=ADP, phon= $prep];
      PRON [cat=PRON, phon= $pron];
      PREP < PRON;
    }
    commands {
      del_node PRON;
      PREP.phon = $amalgam;
      % The three next commands are needed to ensure correct CoNLLU output (without the x-y line for amalgam)
      del_feat PREP._UD_mw_fusion;
      del_feat PREP._UD_mw_span;
      del_feat PREP._UD_MISC_SpaceAfter;
    }
  }
#BEGIN
à#lequel#auquel
à#lesquels#auxquels
à#lesquelles#auxquelles
de#lequel#duquel
de#lesquelles#desquelles
#END
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
strat main {
  Seq (
    Onf (chained_relations),
%    Onf (neg),
    Onf (reverse),
%    Onf (nummod_det), % fr-ud-test_00049 : les 8 premiers épisodes
    Onf (relations),
%    Onf (raise_gov),
    Onf (fail_label),
  )
}

strat udpos {
  Seq (
    Onf (UDPOS_init),
    Onf (chained_relations),
    Onf (reverse),
    Onf (UDPOS_after_reverse),
    Onf (relations),
    Onf (fail_label),
  )
}
