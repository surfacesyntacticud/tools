%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package chained_relations {
  rule conj {
    pattern {
      H -[conj]-> X1;
      e: H -[conj]-> X2;
      X1 << X2;
    }
    without {
      H -[conj]-> X;
      X1 << X; X << X2;
    }
    without {
      H -[conj]-> X;
      X2 << X;
    }
    commands {
      del_edge e;
      add_edge X1 -[conj]-> X2;
    }
  }

  rule fixed {
    pattern {
      H -[fixed]-> X1;
      e: H -[fixed]-> X2;
      X1 << X2;
    }
    without {
      H -[fixed]-> X;
      X1 << X; X << X2;
    }
    without {
      H -[fixed]-> X;
      X2 << X;
    }
    commands {
      del_edge e;
      add_edge X1 -[fixed]-> X2;
    }
  }

  rule flat_name {
    pattern {
      H -[flat:name]-> X1;
      e: H -[flat:name]-> X2;
      X1 << X2;
    }
    without {
      H -[flat:name]-> X;
      X1 << X; X << X2;
    }
    without {
      H -[flat:name]-> X;
      X2 << X;
    }
    commands {
      del_edge e;
      add_edge X1 -[flat:name]-> X2;
    }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package neg {
  rule r {
    pattern { e:V -[advmod]-> A; A[Polarity=Neg] }
    commands { del_edge e; add_edge V -[advmod:neg]-> A; }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package aux {
  rule aux_left {
    pattern {
      V []; AUX [cat=AUX];
      e:V -[aux]-> AUX; AUX << V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop]-> AUX2;
      AUX << AUX2; AUX2 << V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:aux]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[advcl|aux|aux:pass|aux:caus|cop|nsubj|nsubj:pass|punct|conj|cc|root|mark|case|advmod:neg]=> AUX;
    }
  }

  rule cop_left {
    pattern {
      V []; AUX [cat=AUX];
      e:V -[cop]-> AUX; AUX << V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop]-> AUX2;
      AUX << AUX2; AUX2 << V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:cop]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[^ acl|acl:relcl|amod|det|case|nmod|nummod|obl:arg]=> AUX;
%      shift_out V =[advcl|aux|aux:pass|aux:caus|cop|nsubj|nsubj:pass|punct|conj|cc|root|mark|advmod:neg]=> AUX;
    }
  }

  rule auxpass_left {
    pattern {
      V []; AUX [cat=AUX];
      e:V -[aux:pass]-> AUX; AUX << V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop]-> AUX2;
      AUX << AUX2; AUX2 << V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:pass]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|nsubj|nsubj:pass|punct|conj|cc|root|mark|case|advmod:neg]=> AUX;
    }
  }

  rule auxcaus_left {
    pattern {
      V []; AUX [cat=AUX];
      e:V -[aux:caus]-> AUX; AUX << V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop]-> AUX2;
      AUX << AUX2; AUX2 << V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:caus]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|nsubj|nsubj:pass|punct|conj|cc|root|obj:agent|advmod:neg]=> AUX;
    }
  }

  rule aux_right {
    pattern {
      V []; AUX [cat=AUX];
      e:V -[aux]-> AUX; AUX >> V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop]-> AUX2;
      AUX2 >> AUX; AUX2 >> V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:aux]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|nsubj|nsubj:pass|punct|conj|cc|root|mark|case|advmod:neg]=> AUX;
    }
  }

  rule cop_right {
    pattern {
      V []; AUX [cat=AUX];
      e:V -[cop]-> AUX; AUX >> V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop]-> AUX2;
      AUX2 >> AUX; AUX2 >> V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:cop]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[^ acl|acl:relcl|amod|det|case|nmod|nummod|obl:arg]=> AUX;
%      shift_out V =[aux|aux:pass|aux:caus|cop|nsubj|nsubj:pass|punct|conj|cc|root|mark|advmod:neg]=> AUX;
    }
  }

  rule auxpass_right {
    pattern {
      V []; AUX [cat=AUX];
      e:V -[aux:pass]-> AUX; AUX >> V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop]-> AUX2;
      AUX2 >> AUX; AUX2 >> V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:pass]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|nsubj|nsubj:pass|punct|conj|cc|root|mark|case|advmod:neg]=> AUX;
    }
  }

  rule auxcaus_right {
    pattern {
      V []; AUX [cat=AUX];
      e:V -[aux:caus]-> AUX; AUX >> V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop]-> AUX2;
      AUX2 >> AUX; AUX2 >> V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:caus]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|nsubj|nsubj:pass|punct|conj|cc|root|obj:agent|advmod:neg]=> AUX;
    }
  }
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package reverse{
  rule left_case{
    pattern { e:H-[case]->X1; X1 << H; }
    without { H-[mark|case]->X2; X1 << X2 }
    commands {
    del_edge e;
    add_edge X1-[comp]-> H;
    shift_in H==>X1;
    %shift_out H=[^det|aux|aux:pass|nsubj|obj|appos|punct|flat:name|nmod|nummod|comp|amod]=>X1;
    }
  }

  rule left_mark{
    pattern { e:H-[mark]->X1; X1 << H }
    without { H-[mark|case]->X2; X1 << X2 }
    commands {
    del_edge e;
    add_edge X1-[comp]-> H;
    shift_in H==>X1;
    shift_out H=[cc]=>X1;
    }
  }

  rule right_case{
    pattern { e:H-[case]->X1; X1 >> H; }
    without { H-[mark|case]->X2; X1 >> X2 }
    commands {
    del_edge e;
    add_edge X1-[comp]-> H;
    shift_in H==>X1;
    shift_out H=[^det|aux|aux:pass|nsubj|obj|appos|punct|flat:name|nmod|nummod|comp|amod]=>X1;
    }
  }

  rule right_mark{
    pattern { e:H-[mark]->X1; X1 >> H }
    without { H-[mark|case]->X2; X1 >> X2 }
    commands {
    del_edge e;
    add_edge X1-[comp]-> H;
    shift_in H==>X1;
    shift_out H=[^det|comp|comp:aux|comp:cop|aux:pass|nsubj|nsubj:pass|obj|obl:mod|obl:arg]=>X1;
    }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  rule nummod_det {
    pattern { e:M -[nummod]-> N; }
    without { M -[det]-> *}
    without { M[cat=ADJ]; * -[amod|mod]-> M}
    commands { del_edge e; add_edge M -[det]-> N }
  }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package relations {
  rule ccomp_comp_obl {
    pattern { e:M -[obj|ccomp]-> N; N[cat = ADP]; }
    commands { del_edge e; add_edge M -[comp:obl]-> N }
  }
  rule comp_agent {
    pattern { e:M -[obl:agent]-> N; }
    commands { del_edge e; add_edge M -[comp:agent]-> N }
  }
  rule comp_cleft {
    pattern { e:M -[advcl:cleft]-> N; }
    commands { del_edge e; add_edge M -[comp:cleft]-> N }
  }
  rule comp_lvc {
    pattern { e:M -[obj:lvc]-> N; }
    commands { del_edge e; add_edge M -[comp:lvc]-> N }
  }
  rule comp_obj {
    pattern { e:M -[obj|ccomp]-> N; N[cat <> ADP]; }
    commands { del_edge e; add_edge M -[comp:obj]-> N }
  }
  rule comp_obj_caus {
    pattern { e:M -[obj:agent]-> N; }
    commands { del_edge e; add_edge M -[comp:obj]-> N }
  }
  rule comp_obl {
    pattern { e:M -[obl:arg|iobj]-> N; }
    commands { del_edge e; add_edge M -[comp:obl]-> N }
  }
  rule comp_rais {
    pattern { e:M -[xcomp]-> N; }
    commands { del_edge e; add_edge M -[comp:rais]-> N }
  }
  rule dep_obl { % in GSD, obl are not all subtyped
    pattern { e:M -[obl]-> N; }
    commands { del_edge e; add_edge M -[dep:obl]-> N }
  }
  rule mod {
    pattern { e:M -[amod|advmod|advmod:neg|acl|acl:relcl|advcl|obl:mod|nummod]-> N; }
    commands { del_edge e; add_edge M -[mod]-> N }
  }

  rule nmod_dep {
    pattern { e:M -[nmod]-> N; M [cat=SYM|NUM|NOUN|PRON|PROPN]}
    commands { del_edge e; add_edge M -[dep]-> N }
  }
  rule nmod_mod {
    pattern { e:M -[nmod]-> N; M [cat<>SYM|NUM|NOUN|PRON|PROPN]}
    commands { del_edge e; add_edge M -[mod]-> N }
  }
  rule subj {
    pattern { e:M -[nsubj|nsubj:pass|csubj|csubj:pass]-> N; }
    commands { del_edge e; add_edge M -[subj]-> N }
  }

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package raise_gov{
  rule raise_mod{
    pattern {
      G -> D; D >> G; MOD << G;
      mod_rel:D -[mod]-> MOD
    }
%    without { MOD [lemma = "où"]}  French specificity
    commands {
      del_edge mod_rel;
      add_edge G -[mod]-> MOD
    }
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package fail_label{

  rule FAIL_acl{
    pattern{e: G -[acl]-> D}
    commands{del_edge e; add_edge G -[FAIL_acl]-> D}
  }

  rule FAIL_advcl{
    pattern{e: G -[advcl]-> D}
    commands{del_edge e; add_edge G -[FAIL_advcl]-> D}
  }

  rule FAIL_advmod{
    pattern{e: G -[advmod]-> D}
    commands{del_edge e; add_edge G -[FAIL_advmod]-> D}
  }

  rule FAIL_amod{
    pattern{e: G -[amod]-> D}
    commands{del_edge e; add_edge G -[FAIL_amod]-> D}
  }

  rule FAIL_aux{
    pattern{e: G -[aux]-> D}
    commands{del_edge e; add_edge G -[FAIL_aux]-> D}
  }

  rule FAIL_case{
    pattern{e: G -[case]-> D}
    commands{del_edge e; add_edge G -[FAIL_case]-> D}
  }

  rule FAIL_ccomp{
    pattern{e: G -[ccomp]-> D}
    commands{del_edge e; add_edge G -[FAIL_ccomp]-> D}
  }

  rule FAIL_cop{
    pattern{e: G -[cop]-> D}
    commands{del_edge e; add_edge G -[FAIL_cop]-> D}
  }

  rule FAIL_csubj{
    pattern{e: G -[csubj]-> D}
    commands{del_edge e; add_edge G -[FAIL_csubj]-> D}
  }

  rule FAIL_iobj{
    pattern{e: G -[iobj]-> D}
    commands{del_edge e; add_edge G -[FAIL_iobj]-> D}
  }

  rule FAIL_mark{
    pattern{e: G -[mark]-> D}
    commands{del_edge e; add_edge G -[FAIL_mark]-> D}
  }

  rule FAIL_nmod{
    pattern{e: G -[nmod]-> D}
    commands{del_edge e; add_edge G -[FAIL_nmod]-> D}
  }

  rule FAIL_nsubj{
    pattern{e: G -[nsubj]-> D}
    commands{del_edge e; add_edge G -[FAIL_nsubj]-> D}
  }

  rule FAIL_nummod{
    pattern{e: G -[nummod]-> D}
    commands{del_edge e; add_edge G -[FAIL_nummod]-> D}
  }

  rule FAIL_obj{
    pattern{e: G -[obj]-> D}
    commands{del_edge e; add_edge G -[FAIL_obj]-> D}
  }

  rule FAIL_obl{
    pattern{e: G -[obl]-> D}
    commands{del_edge e; add_edge G -[FAIL_obl]-> D}
  }

  rule FAIL_xcomp{
    pattern{e: G -[xcomp]-> D}
    commands{del_edge e; add_edge G -[FAIL_xcomp]-> D}
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package amalgam {
  rule prep_det (feature $prep, $det, $amalgam) {
    pattern {
      P [cat=ADP, phon= $prep];
      D [cat=DET, phon= $det];
      P < D;
    }
    commands {
      del_node D;
      P.phon = $amalgam;
      % The three next commands are needed to ensure correct CoNLLU output (without the x-y line for amalgam)
      del_feat P._UD_mw_fusion;
      del_feat P._UD_mw_span;
      del_feat P._UD_MISC_SpaceAfter;
    }
  }
#BEGIN
à#le#au
à#les#aux
de#le#du
de#les#des
#END

  rule prep_pro (feature $prep, $pron, $amalgam) {
    pattern {
      PREP [cat=ADP, phon= $prep];
      PRON [cat=PRON, phon= $pron];
      PREP < PRON;
    }
    commands {
      del_node PRON;
      PREP.phon = $amalgam;
      % The three next commands are needed to ensure correct CoNLLU output (without the x-y line for amalgam)
      del_feat PREP._UD_mw_fusion;
      del_feat PREP._UD_mw_span;
      del_feat PREP._UD_MISC_SpaceAfter;
    }
  }
#BEGIN
à#lequel#auquel
à#lesquels#auxquels
à#lesquelles#auxquelles
de#lequel#duquel
de#lesquelles#desquelles
#END
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
strat main {
  Seq (
    Onf (chained_relations),
    Onf (neg),
    Onf (aux),
    Onf (reverse),
    Onf (nummod_det), % fr-ud-test_00049 : les 8 premiers épisodes
    Onf (relations),
    Onf (raise_gov),
    Onf (fail_label),
%    Onf (amalgam),
  )
}

strat full {
  Seq (
    Iter (chained_relations),
    Onf (neg), % trivially confluent
    Iter (aux_left), Iter (aux_right),
    Iter (reverse),
    Iter (relations),
%    Onf (amalgam),
  )
}
