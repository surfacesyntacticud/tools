package chained_relations {
  rule conj {
    pattern {
      H -[conj]-> X1;
      e: H -[conj]-> X2;
      X1 << X2;
    }
    without {
      H -[conj]-> X;
      X1 << X; X << X2;
    }
    without {
      H -[conj]-> X;
      X2 << X;
    }
    commands {
      del_edge e;
      add_edge X1 -[conj]-> X2;
    }
  }

  rule fixed {
    pattern {
      H -[fixed]-> X1;
      e: H -[fixed]-> X2;
      X1 << X2;
    }
    without {
      H -[fixed]-> X;
      X1 << X; X << X2;
    }
    without {
      H -[fixed]-> X;
      X2 << X;
    }
    commands {
      del_edge e;
      add_edge X1 -[fixed]-> X2;
    }
  }

  rule flat_name {
    pattern {
      H -[flat:name]-> X1;
      e: H -[flat:name]-> X2;
      X1 << X2;
    }
    without {
      H -[flat:name]-> X;
      X1 << X; X << X2;
    }
    without {
      H -[flat:name]-> X;
      X2 << X;
    }
    commands {
      del_edge e;
      add_edge X1 -[flat:name]-> X2;
    }
  }
}

package neg {
  rule r {
    pattern { e:V -[advmod]-> A; A[Polarity=Neg] }
    commands { del_edge e; add_edge V -[advmod:neg]-> A; }
  }
}

package aux_left {
  rule aux {
    pattern {
      V []; AUX [cat=AUX];
      e:V -[aux]-> AUX; AUX << V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop]-> AUX2;
      AUX << AUX2; AUX2 << V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:aux]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|nsubj|nsubj:pass|punct|conj|cc|root|mark|case|advmod:neg]=> AUX;
    }
  }

  rule cop {
    pattern {
      V []; AUX [cat=AUX];
      e:V -[cop]-> AUX; AUX << V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop]-> AUX2;
      AUX << AUX2; AUX2 << V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:cop]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|nsubj|nsubj:pass|punct|conj|cc|root|mark|advmod:neg]=> AUX;
    }
  }

  rule auxpass {
    pattern {
      V []; AUX [cat=AUX];
      e:V -[aux:pass]-> AUX; AUX << V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop]-> AUX2;
      AUX << AUX2; AUX2 << V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:pass]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|nsubj|nsubj:pass|punct|conj|cc|root|mark|case|advmod:neg]=> AUX;
    }
  }

  rule auxcaus {
    pattern {
      V []; AUX [cat=AUX];
      e:V -[aux:caus]-> AUX; AUX << V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop]-> AUX2;
      AUX << AUX2; AUX2 << V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:caus]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|nsubj|nsubj:pass|punct|conj|cc|root|obj:agent|advmod:neg]=> AUX;
    }
  }
}

package aux_right {
  rule aux {
    pattern {
      V []; AUX [cat=AUX];
      e:V -[aux]-> AUX; AUX >> V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop]-> AUX2;
      AUX >> AUX2; AUX2 >> V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:aux]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|nsubj|nsubj:pass|punct|conj|cc|root|mark|case|advmod:neg]=> AUX;
    }
  }

  rule cop {
    pattern {
      V []; AUX [cat=AUX];
      e:V -[cop]-> AUX; AUX >> V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop]-> AUX2;
      AUX >> AUX2; AUX2 >> V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:cop]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|nsubj|nsubj:pass|punct|conj|cc|root|mark|advmod:neg]=> AUX;
    }
  }

  rule auxpass {
    pattern {
      V []; AUX [cat=AUX];
      e:V -[aux:pass]-> AUX; AUX >> V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop]-> AUX2;
      AUX >> AUX2; AUX2 >> V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:pass]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|nsubj|nsubj:pass|punct|conj|cc|root|mark|case|advmod:neg]=> AUX;
    }
  }

  rule auxcaus {
    pattern {
      V []; AUX [cat=AUX];
      e:V -[aux:caus]-> AUX; AUX >> V;
    }
    without {
      V -[aux|aux:pass|aux:caus|cop]-> AUX2;
      AUX >> AUX2; AUX2 >> V;
    }
    commands {
      del_edge e;
      add_edge AUX -[comp:caus]-> V;
      AUX.cat=VERB;
      shift_in V ==> AUX;
      shift_out V =[aux|aux:pass|aux:caus|cop|nsubj|nsubj:pass|punct|conj|cc|root|obj:agent|advmod:neg]=> AUX;
    }
  }
}

package relations {
  rule comp_lvc {
    pattern { e:M -[obj:lvc]-> N; }
    commands { del_edge e; add_edge M -[comp:lvc]-> N }
  }
  rule mod {
    pattern { e:M -[amod|advmod|advmod:neg|nummod|acl|advcl|obl:mod]-> N; }
    commands { del_edge e; add_edge M -[mod]-> N }
  }
  rule nmod_dep {
    pattern { e:M -[nmod]-> N; M [cat=SYM|NUM|NOUN|PRON|PROPN]}
    commands { del_edge e; add_edge M -[dep]-> N }
  }
  rule nmod_mod {
    pattern { e:M -[nmod]-> N; M [cat<>SYM|NUM|NOUN|PRON|PROPN]}
    commands { del_edge e; add_edge M -[mod]-> N }
  }
  rule subj {
    pattern { e:M -[nsubj|nsubj:pass|csubj|csubj:pass]-> N; }
    commands { del_edge e; add_edge M -[subj]-> N }
  }
  rule comp_obj {
    pattern { e:M -[obj|ccomp]-> N; N[cat <> ADP]; }
    commands { del_edge e; add_edge M -[comp:obj]-> N }
  }
  rule ccomp_comp_obl {
    pattern { e:M -[obj|ccomp]-> N; N[cat = ADP]; }
    commands { del_edge e; add_edge M -[comp:obl]-> N }
  }
  rule comp_obj_caus {
    pattern { e:M -[obj:agent]-> N; }
    commands { del_edge e; add_edge M -[comp:obj]-> N }
  }
  rule comp_obl {
    pattern { e:M -[obl:arg|iobj]-> N; }
    commands { del_edge e; add_edge M -[comp:obl]-> N }
  }
  rule comp_agent {
    pattern { e:M -[obl:agent]-> N; }
    commands { del_edge e; add_edge M -[comp:agent]-> N }
  }
  rule comp_rais {
    pattern { e:M -[xcomp]-> N; }
    commands { del_edge e; add_edge M -[comp:rais]-> N }
  }
  rule dep { % in GSD, obl are not all subtyped
    pattern { e:M -[obl]-> N; }
    commands { del_edge e; add_edge M -[dep]-> N }
  }

}


package reverse{
  rule left_case{
    pattern { e:H-[case]->X1; X1 << H; }
    without { H-[mark|case]->X2; X1 << X2 }
    commands {
    del_edge e;
    add_edge X1-[comp]-> H;
    shift_in H==>X1;
    shift_out H=[^det|aux|aux:pass|nsubj|obj|appos|punct|flat:name|nmod|nummod|comp|amod]=>X1;
    }
  }

  rule left_mark{
    pattern { e:H-[mark]->X1; X1 << H }
    without { H-[mark|case]->X2; X1 << X2 }
    commands {
    del_edge e;
    add_edge X1-[comp]-> H;
    shift_in H==>X1;
    shift_out H=[^det|comp|comp:aux|comp:cop|comp:pass|aux:pass|nsubj|nsubj:pass|obj|obl:mod|obl:arg|obl]=>X1;
    }
  }

  rule right_case{
    pattern { e:H-[case]->X1; X1 >> H; }
    without { H-[mark|case]->X2; X1 >> X2 }
    commands {
    del_edge e;
    add_edge X1-[comp]-> H;
    shift_in H==>X1;
    shift_out H=[^det|aux|aux:pass|nsubj|obj|appos|punct|flat:name|nmod|nummod|comp|amod]=>X1;
    }
  }

  rule right_mark{
    pattern { e:H-[mark]->X1; X1 >> H }
    without { H-[mark|case]->X2; X1 >> X2 }
    commands {
    del_edge e;
    add_edge X1-[comp]-> H;
    shift_in H==>X1;
    shift_out H=[^det|comp|comp:aux|comp:cop|aux:pass|nsubj|nsubj:pass|obj|obl:mod|obl:arg]=>X1;
    }
  }
}

package amalgam {
  rule prep_det (feature $prep, $det, $amalgam) {
    pattern {
      P [cat=ADP, phon= $prep];
      D [cat=DET, phon= $det];
      P < D;
    }
    commands {
      del_node D;
      P.phon = $amalgam;
      % The three next commands are needed to ensure correct CoNLLU output (without the x-y line for amalgam)
      del_feat P._UD_mw_fusion;
      del_feat P._UD_mw_span;
      del_feat P._UD_MISC_SpaceAfter;
    }
  }
#BEGIN
à#le#au
à#les#aux
de#le#du
de#les#des
#END

  rule prep_pro (feature $prep, $pron, $amalgam) {
    pattern {
      PREP [cat=ADP, phon= $prep];
      PRON [cat=PRON, phon= $pron];
      PREP < PRON;
    }
    commands {
      del_node PRON;
      PREP.phon = $amalgam;
      % The three next commands are needed to ensure correct CoNLLU output (without the x-y line for amalgam)
      del_feat PREP._UD_mw_fusion;
      del_feat PREP._UD_mw_span;
      del_feat PREP._UD_MISC_SpaceAfter;
    }
  }
#BEGIN
à#lequel#auquel
à#lesquels#auxquels
à#lesquelles#auxquelles
de#lequel#duquel
de#lesquelles#desquelles
#END
}


strat main {
  Seq (
    Onf (chained_relations),
    Onf (neg),
    Onf (aux_left), Onf (aux_right),
    Onf (reverse),
    Onf (relations),
%    Onf (amalgam),
  )
}

strat full {
  Seq (
    Iter (chained_relations),
    Onf (neg), % trivially confluent
    Iter (aux_left), Iter (aux_right),
    Iter (reverse),
    Iter (relations),
%    Onf (amalgam),
  )
}
