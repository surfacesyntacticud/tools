package UDPOS_init {
  rule case {
    pattern { X -[case]-> Y }
    without { Y [upos=ADP|PART] }
    without { Y [_MISC_MWEPOS=ADP|PART] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = ADP} % real value should be "ADP|PART"
  }

  rule mark {
    pattern { X -[mark]-> Y }
    without { Y [upos=ADP|SCONJ] }
    without { Y [_MISC_MWEPOS=ADP|SCONJ] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = ADP} % real value should be "ADP|SCONJ"
  }

  rule cop {
    pattern { X -[cop]-> Y }
    without { Y [upos=AUX] }
    without { Y [_MISC_MWEPOS=AUX] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = AUX}
  }

  rule aux {
    pattern { X -[re"aux.*"]-> Y }
    without { Y [upos=AUX] }
    without { Y [_MISC_MWEPOS=AUX] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = AUX}
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package UDPOS_after_reverse {
  rule amod {
    pattern { X -[amod]-> Y }
    without { Y [upos=ADJ] }
    without { Y [_MISC_MWEPOS=ADJ] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = ADJ}
  }

  rule advmod {
    pattern { X -[advmod]-> Y }
    without { Y [upos=ADV] }
    without { Y [_MISC_MWEPOS=ADV] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = ADV}
  }

  rule nsubj {
    pattern { X -[re"nsubj.*"]-> Y }
    without { Y [upos=NOUN|PROPN|PRON] }
    without { Y [_MISC_MWEPOS=NOUN|PROPN|PRON] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = NOUN}
  }

  rule csubj {
    pattern { X -[re"csubj.*"]-> Y }
    without { Y [upos=VERB] }
    without { Y [_MISC_MWEPOS=VERB] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = VERB}
  }

  rule acl_advcl {
    pattern { X -[acl|advcl]-> Y }
    without { Y [upos=VERB|ADJ] }
    without { Y [_MISC_MWEPOS=VERB|ADJ] }
    without { Y [_MISC_UDPOS] }
    commands { Y._MISC_UDPOS = VERB} % real value should be "VERB|ADJ"
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Move the dependents of a conjunction from the left conjunct to the right conjunct. Dependencies ADVCL, ADVMOD, APPOS, CCOMP, CONJ, DEP, DISCOURSE, PARATAXIS and PUNCT are not moved.
package minimize_conj_dep{

  rule min_acl{
    pattern{C1 -[conj]-> C2; e:C1 -[acl]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[acl]-> D}
  }
  
  rule min_aclrelcl{
    pattern{C1 -[conj]-> C2; e:C1 -[acl:relcl]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[acl:relcl]-> D}
  }

  rule min_amod{
    pattern{C1 -[conj]-> C2; e:C1 -[amod]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[amod]-> D}
  }
  
  rule min_flatname{
    pattern{C1 -[conj]-> C2; e:C1 -[flat:name]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[flat:name]-> D}
  }
  
  rule min_nmod{
    pattern{C1 -[conj]-> C2; e:C1 -[nmod]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[nmod]-> D}
  }
  
  rule min_nsubj{
    pattern{C1 -[conj]-> C2; e:C1 -[nsubj]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[nsubj]-> D}
  }
  
  rule min_nummod{
    pattern{C1 -[conj]-> C2; e:C1 -[nummod]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[nummod]-> D}
  }
  rule min_obj{
    pattern{C1 -[conj]-> C2; e:C1 -[obj]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[obj]-> D}
  }
  
  rule min_obl{
    pattern{C1 -[conj]-> C2; e:C1 -[obl]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[obl]-> D}
  }

  rule min_oblagent{
    pattern{C1 -[conj]-> C2; e:C1 -[obl:agent]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[obl:agent]-> D}
  }

  rule min_oblarg{
    pattern{C1 -[conj]-> C2; e:C1 -[obl:arg]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[obl:arg]-> D}
  }
  rule min_oblmod{
    pattern{C1 -[conj]-> C2; e:C1 -[obl:mod]-> D; C2 << D}
    without{C1 -[conj]-> C; C2 << C}
    commands{del_edge e; add_edge C2 -[obl:mod]-> D}
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dependencies of type CONJ, FIXED and FLAT:NAME grouped into a bouquet are reorganized into a chain.
package chained_relations {
  rule conj {
    pattern {
      H -[conj]-> X1;
      e: H -[conj]-> X2;
      X1 << X2;
    }
    without {
      H -[conj]-> X;
      X1 << X; X << X2;
    }
    without {
      H -[conj]-> X;
      X2 << X;
    }
    commands {
      del_edge e;
      add_edge X1 -[conj]-> X2;
    }
  }

  rule fixed {
    pattern {
      H -[fixed]-> X1;
      e: H -[fixed]-> X2;
      X1 << X2;
    }
    without {
      H -[fixed]-> X;
      X1 << X; X << X2;
    }
    without {
      H -[fixed]-> X;
      X2 << X;
    }
    commands {
      del_edge e;
      add_edge X1 -[fixed]-> X2;
    }
  }

  rule flat_name {
    pattern {
      H -[flat:name]-> X1;
      e: H -[flat:name]-> X2;
      X1 << X2;
    }
    without {
      H -[flat:name]-> X;
      X1 << X; X << X2;
    }
    without {
      H -[flat:name]-> X;
      X2 << X;
    }
    commands {
      del_edge e;
      add_edge X1 -[flat:name]-> X2;
    }
  }
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% For the auxiliaries, the rule of starting with the closest dependent does not work in the cases of extraposition of the predicate.
% Ex: fr-ud-test_00067-  ... ce que nous avons été ...
% The rule that works in all cases is based on an order between types of auxiliaries : cop < tense auxiliairy and passive auxiliary < tense auxiliary.
% The change of head for auxiliary relations must be processed together with the change of heads for case and mark relations. The rule is to start with the old dependent that is the closest to the old head while taking the order between types of auxiliaries into account.
% Ex: Il a été en retard ce matin. (case < cop < aux)
% Ex : Il part sans avoir été malade un seul jour. (cop < aux < mark)
package reverse {
  rule aux {
    pattern {e:P -[aux]-> AUX}
    without { P-[mark]->X; AUX << X ; X << P} % Il a semblé que Marie arrivait.
    without { P-[mark]->X; AUX >> X ; X >> P}
    without {P -[aux|aux:pass|aux:caus|cop]-> AUX2}
    without{ P -[conj]-> *}
    commands {
      del_edge e;
      add_edge AUX -[comp:aux]-> P;
      AUX.cat=VERB;
      shift_in P ==> AUX;
      shift_out P =[mark]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }

  rule aux_conj1 {
    pattern {e:P -[aux]-> AUX; P -[conj]-> P1}
    without { P-[mark]->X; AUX << X ; X << P}
    without { P-[mark]->X; AUX >> X ; X >> P}
    without {P -[aux|aux:pass|aux:caus|cop]-> AUX2 }
    without{ P1[VerbForm]; AUX.VerbForm = P1.VerbForm}
    commands {
      del_edge e;
      add_edge AUX -[comp:aux]-> P;
      AUX.cat=VERB;
      shift_in P ==> AUX;
      shift_out P =[mark]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }
  
  rule aux_conj2 {
    pattern {
      e1:P -[aux]-> AUX; e2:P -[conj]-> P1;
      P1[VerbForm]; AUX.VerbForm = P1.VerbForm
    }
    without { P-[mark]->X; AUX << X ; X << P}
    without { P-[mark]->X; AUX >> X ; X >> P}
    without {P -[aux|aux:pass|aux:caus|cop]-> AUX2}
    commands {
      del_edge e1;  del_edge e2;
      add_edge AUX -[comp:aux]-> P;
      add_edge AUX -[conj]-> P1;
      AUX.cat=VERB;
      shift_in P ==> AUX;
      shift_out P =[mark]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }
  
  rule cop {
    pattern {e:P -[cop]-> AUX}
    without { P-[mark]->X; AUX << X ; X << P}
    without { P-[mark]->X; AUX >> X ; X >> P}
    without{ P -[conj]-> *}
    commands {
      del_edge e;
      add_edge AUX -[comp:cop]-> P;
      AUX.cat=VERB;
      shift_in P ==> AUX;
      shift_out P =[aux|mark]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }

  rule cop_conj1 {
    pattern {e:P -[cop]-> AUX;P -[conj]-> P1}
    without { P-[mark]->X; AUX << X ; X << P}
    without { P-[mark]->X; AUX >> X ; X >> P}
    without{ P1 -[aux|aux:pass|aux:caus|cop|mark|case]-> AUX2}
    without{ P1[VerbForm]; AUX.VerbForm = P1.VerbForm}
    commands {
      del_edge e;
      add_edge AUX -[comp:cop]-> P;
      AUX.cat=VERB;
      shift_in P ==> AUX;
      shift_out P =[aux|mark]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }

  rule cop_conj2 {
    pattern {
      e1:P -[cop]-> AUX; e2:P -[conj]-> P1;
      P1[VerbForm]; AUX.VerbForm = P1.VerbForm
    }
    without { P-[mark]->X; AUX << X ; X << P}
    without { P-[mark]->X; AUX >> X ; X >> P}
    without{ P1 -[aux|aux:pass|aux:caus|cop|mark|case]-> AUX2}
    commands {
      del_edge e1;  del_edge e2;
      add_edge AUX -[comp:cop]-> P;
      add_edge AUX -[conj]-> P1;
      AUX.cat=VERB;
      shift_in P ==> AUX;
      shift_out P =[aux|mark]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }
  
  rule auxpass {
    pattern {e:P -[aux:pass]-> AUX}
    without{ P -[conj]-> *}
    commands {
      del_edge e;
      add_edge AUX -[comp:pass]-> P;
      AUX.cat=VERB;
      shift_in P ==> AUX;
      shift_out P =[aux|mark]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }

  rule auxpass_conj1 {
    pattern {e:P -[aux:pass]-> AUX; P -[conj]-> P1}
    without{ P1 -[aux|aux:pass|aux:caus|cop|mark|case]-> AUX2}
    without{ P1[VerbForm]; AUX.VerbForm = P1.VerbForm}
    commands {
      del_edge e;
      add_edge AUX -[comp:pass]-> P;
      AUX.cat=VERB;
      shift_in P ==> AUX;
      shift_out P =[aux|mark]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }
  
  rule auxpass_conj2 {
    pattern {
      e1:P -[aux:pass]-> AUX; e2:P -[conj]-> P1;
      P1[VerbForm]; AUX.VerbForm = P1.VerbForm
    }
    without{ P1 -[aux|aux:pass|aux:caus|cop|mark|case]-> AUX2}
    commands {
      del_edge e1;  del_edge e2;
      add_edge AUX -[comp:pass]-> P;
      add_edge AUX -[conj]-> P1;
      AUX.cat=VERB;
      shift_in P ==> AUX;
      shift_out P =[aux|aux:pass|aux:caus|cop|mark|case]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }
 
  rule auxcaus {
    pattern {e:P -[aux:caus]-> AUX}
    without{ P -[conj]-> *}
    commands {
      del_edge e;
      add_edge AUX -[comp:caus]-> P;
      AUX.cat=VERB;
      shift_in P ==> AUX;
      shift_out P =[aux|mark]=> AUX;
      shift_out P =[obj:agent|obl:agent]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }

  rule auxcaus_conj1 {
    pattern {e:P -[aux:caus]-> AUX; P -[conj]-> P1}
    without{ P1 -[aux|aux:pass|aux:caus|cop|mark|case]-> AUX2}
    without{ P1[VerbForm]; AUX.VerbForm = P1.VerbForm}
    commands {
      del_edge e;
      add_edge AUX -[comp:caus]-> P;
      AUX.cat=VERB;
      shift_in P ==> AUX;
      shift_out P =[aux|mark]=> AUX;
      shift_out P =[obj:agent|obl:agent]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }
  
  rule auxcaus_conj2 {
    pattern {
      e1:P -[aux:caus]-> AUX; AUX << P;
      e2:P -[conj]-> P1;
      P1[VerbForm]; AUX.VerbForm = P1.VerbForm
    }
   without{ P1 -[aux|aux:pass|aux:caus|cop|mark|case]-> AUX2}
    commands {
      del_edge e1;  del_edge e2;
      add_edge AUX -[comp:caus]-> P;
      add_edge AUX -[conj]-> P1;
      AUX.cat=VERB;
      shift_in P ==> AUX;
      shift_out P =[aux|mark]=> AUX;
      shift_out P =[obj:agent|obl:agent]=> AUX;
      shift_out P =[advmod|obl:mod|advcl|nsubj|nsubj:pass|csubj|csubj:pass|cc|punct|root]=> AUX;
    }
  }

  rule case{
    pattern { e:H-[case]->X1}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 << X2 ; X2 << H}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 >> X2 ; X2 >> H}
    without{H -[conj]-> *}
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H==>X1;
      shift_out H =[aux|aux:pass|aux:caus|cop|mark|case]=> X1;
      shift_out H =[advcl|cc|csubj|nsubj|punct|root]=> X1;
    }
  }

  rule case_conj1{
    pattern { e:H-[case]->X1; H -[conj]-> H1}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 << X2 ; X2 << H}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 >> X2 ; X2 >> H}
    without {H1 -[aux|aux:pass|aux:caus|cop|mark|case]-> FUNCT; FUNCT << H1}
    without{ H1[cat=ADP|SCONJ]; H1 -[comp]-> *}
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H==>X1;
      shift_out H =[aux|aux:pass|aux:caus|cop|mark|case]=> X1;
      shift_out H =[advcl|cc|csubj|nsubj|punct|root]=> X1;
    }
  }
  
  rule case_conj2{
    pattern {
      e1:H-[case]->X1; e2: H -[conj]-> H1;
      H1[cat=ADP|SCONJ]; H1 -[comp]-> *
    }
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 << X2 ; X2 << H}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 >> X2 ; X2 >> H}
    without {H1 -[aux|aux:pass|aux:caus|cop|mark|case]-> FUNCT; FUNCT << H1}
    commands {
      del_edge e1; del_edge e2;
      add_edge X1-[comp]-> H; add_edge X1 -[conj]-> H1;
      shift_in H==>X1;
      shift_out H =[aux|aux:pass|aux:caus|cop|mark|case]=> X1;
      shift_out H =[advcl|cc|csubj|nsubj|punct|root]=> X1;
    }
  }

  rule mark{
    pattern { e:H-[mark]->X1}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 << X2 ; X2 << H}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 >> X2 ; X2 >> H}
    without{H -[conj]-> *}
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H==>X1;
      shift_out H =[aux|aux:pass|aux:caus|cop|mark|case]=> X1;
      shift_out H =[cc|punct|root]=> X1;
    }
  }

  rule mark_conj1{
    pattern { e:H-[mark]->X1; H -[conj]-> H1}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 << X2 ; X2 << H}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 >> X2 ; X2 >> H}
    without {H1 -[aux|aux:pass|aux:caus|cop|mark|case]-> FUNCT; FUNCT << H1}
    without{ H1[cat=ADP|SCONJ]; H1 -[comp]-> *}
    commands {
      del_edge e;
      add_edge X1-[comp]-> H;
      shift_in H==>X1;
      shift_out H =[aux|aux:pass|aux:caus|cop|mark|case]=> X1;
      shift_out H =[cc|punct|root]=> X1;
    }
  }
  
  rule mark_conj2{
    pattern {
      e1:H-[mark]->X1; e2: H -[conj]-> H1;
      H1[cat=ADP|SCONJ]; H1 -[comp]-> *
    }
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 << X2 ; X2 << H}
    without { H-[aux|aux:pass|aux:caus|cop|mark|case]->X2; X1 >> X2 ; X2 >> H}
    without {H1 -[aux|aux:pass|aux:caus|cop|mark|case]-> FUNCT; FUNCT << H1}
    commands {
      del_edge e1; del_edge e2;
      add_edge X1-[comp]-> H; add_edge X1 -[conj]-> H1;
      shift_in H==>X1;
      shift_out H =[aux|aux:pass|aux:caus|cop|mark|case]=> X1;
      shift_out H =[cc|punct|root]=> X1;
    }
  }

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package FR_nummod{
  % rule nummod_mod1 {
  %   pattern { e:H -[nummod]-> N; H -[det]-> * }
  %   commands { del_edge e; add_edge H -[mod]-> N }
  % }
  
  % rule nummod_mod2 {
  %   pattern { e:H -[nummod]-> N; H << N}
  %   commands { del_edge e; add_edge H -[mod]-> N }
  % }
  
  % rule nummod_mod3 {
  %   pattern { e:H -[nummod]-> N;  H[cat=ADJ]; * -[amod|mod]-> H}
  %   without { H -[det]-> *}
  %   commands { del_edge e; add_edge H -[mod]-> N }
  % }
  
  rule nummod_det {
    pattern { e:H -[nummod]-> N; N << H}
    without { H -[det]-> *}
    without{ * -[det]-> H}
    without { H[cat=ADJ]; * -[amod|mod]-> H}
    commands { del_edge e; add_edge H -[det]-> N }
  }

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package relations {
  rule ccomp_comp_obl {
    pattern { e:H -[obj|ccomp]-> C; C[cat = ADP]; }
    commands { del_edge e; add_edge H -[comp:obl]-> C }
  }
  rule comp_agent {
    pattern { e:H -[obl:agent]-> C; }
    commands { del_edge e; add_edge H -[comp:agent]-> C }
  }
  rule comp_cleft {
    pattern { e:H -[advcl:cleft]-> C; }
    commands { del_edge e; add_edge H -[comp:cleft]-> C }
  }
  rule comp_lvc {
    pattern { e:H -[obj:lvc]-> C; }
    commands { del_edge e; add_edge H -[comp:lvc]-> C }
  }
  rule comp_obj {
    pattern { e:H -[obj|obj:agent|ccomp]-> C; C[cat <> ADP]; }
    commands { del_edge e; add_edge H -[comp:obj]-> C }
  }
  rule comp_obj_caus {
    pattern { e:H -[obj:agent]-> C; A -[comp:caus]-> H}
    commands { del_edge e; add_edge A -[comp:obj]-> C }
  }
  rule comp_obl {
    pattern { e:H -[obl:arg|iobj]-> C; }
    commands { del_edge e; add_edge H -[comp:obl]-> C }
  }
  rule comp_rais {
    pattern { e:H -[xcomp]-> C; }
    commands { del_edge e; add_edge H -[comp:rais]-> C }
  }
  rule dep { % in GSD, obl are not all subtyped
    pattern { e:H -[obl]-> C; }
    commands { del_edge e; add_edge H -[dep_SUD]-> C }
  }
  rule mod {
    pattern { e:H -[advmod|advmod:neg|advcl|obl:mod]-> C; }
    commands { del_edge e; add_edge H -[mod]-> C }
  }
  rule subj {
    pattern { e:H -[nsubj|nsubj:pass|csubj|csubj:pass]-> C}
    commands { del_edge e; add_edge H -[subj]-> C }
  }
  rule nmod_dep {
    pattern { e:H -[acl|acl:relcl|amod|nmod|nummod]-> C}
    commands { del_edge e; add_edge H -[dep_SUD]-> C }
  }
  
  rule nummod_dep {
    pattern { e:H -[nummod]-> N}
    commands { del_edge e; add_edge H -[dep_SUD]-> N }
  }

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package raise_gov{
  rule raise_mod{
    pattern {
      G -> D; D >> G; MOD << G;
      mod_rel:D -[mod]-> MOD
    }
    without { MOD [PronType=Rel]} 
    commands {
      del_edge mod_rel;
      add_edge G -[mod]-> MOD
    }
  }

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package fail_label{

  rule FAIL_acl{
    pattern{e: G -[acl]-> D}
    commands{del_edge e; add_edge G -[FAIL_acl]-> D}
  }

  rule FAIL_advcl{
    pattern{e: G -[advcl]-> D}
    commands{del_edge e; add_edge G -[FAIL_advcl]-> D}
  }

  rule FAIL_advmod{
    pattern{e: G -[advmod]-> D}
    commands{del_edge e; add_edge G -[FAIL_advmod]-> D}
  }

  rule FAIL_amod{
    pattern{e: G -[amod]-> D}
    commands{del_edge e; add_edge G -[FAIL_amod]-> D}
  }

  rule FAIL_aux{
    pattern{e: G -[aux]-> D}
    commands{del_edge e; add_edge G -[FAIL_aux]-> D}
  }

  rule FAIL_case{
    pattern{e: G -[case]-> D}
    commands{del_edge e; add_edge G -[FAIL_case]-> D}
  }

  rule FAIL_ccomp{
    pattern{e: G -[ccomp]-> D}
    commands{del_edge e; add_edge G -[FAIL_ccomp]-> D}
  }

  rule FAIL_cop{
    pattern{e: G -[cop]-> D}
    commands{del_edge e; add_edge G -[FAIL_cop]-> D}
  }

  rule FAIL_csubj{
    pattern{e: G -[csubj]-> D}
    commands{del_edge e; add_edge G -[FAIL_csubj]-> D}
  }

  rule FAIL_iobj{
    pattern{e: G -[iobj]-> D}
    commands{del_edge e; add_edge G -[FAIL_iobj]-> D}
  }

  rule FAIL_mark{
    pattern{e: G -[mark]-> D}
    commands{del_edge e; add_edge G -[FAIL_mark]-> D}
  }

  rule FAIL_nmod{
    pattern{e: G -[nmod]-> D}
    commands{del_edge e; add_edge G -[FAIL_nmod]-> D}
  }

  rule FAIL_nsubj{
    pattern{e: G -[nsubj]-> D}
    commands{del_edge e; add_edge G -[FAIL_nsubj]-> D}
  }

  rule FAIL_nummod{
    pattern{e: G -[nummod]-> D}
    commands{del_edge e; add_edge G -[FAIL_nummod]-> D}
  }

  rule FAIL_obj{
    pattern{e: G -[obj]-> D}
    commands{del_edge e; add_edge G -[FAIL_obj]-> D}
  }

  rule FAIL_obl{
    pattern{e: G -[obl]-> D}
    commands{del_edge e; add_edge G -[FAIL_obl]-> D}
  }

  rule FAIL_xcomp{
    pattern{e: G -[xcomp]-> D}
    commands{del_edge e; add_edge G -[FAIL_xcomp]-> D}
  }

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
package amalgam {
  rule prep_det (feature $prep, $det, $amalgam) {
    pattern {
      P [cat=ADP, phon= $prep];
      D [cat=DET, phon= $det];
      P < D;
    }
    commands {
      del_node D;
      P.phon = $amalgam;
      % The three next commands are needed to ensure correct CoNLLU output (without the x-y line for amalgam)
      del_feat P._UD_mw_fusion;
      del_feat P._UD_mw_span;
      del_feat P._UD_MISC_SpaceAfter;
    }
  }
#BEGIN
à#le#au
à#les#aux
de#le#du
de#les#des
#END

  rule prep_pro (feature $prep, $pron, $amalgam) {
    pattern {
      PREP [cat=ADP, phon= $prep];
      PRON [cat=PRON, phon= $pron];
      PREP < PRON;
    }
    commands {
      del_node PRON;
      PREP.phon = $amalgam;
      % The three next commands are needed to ensure correct CoNLLU output (without the x-y line for amalgam)
      del_feat PREP._UD_mw_fusion;
      del_feat PREP._UD_mw_span;
      del_feat PREP._UD_MISC_SpaceAfter;
    }
  }
#BEGIN
à#lequel#auquel
à#lesquels#auxquels
à#lesquelles#auxquelles
de#lequel#duquel
de#lesquelles#desquelles
#END
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
strat main {
  Seq (
    Onf (minimize_conj_dep),
    Onf (chained_relations),
    Onf (reverse),
    Onf (FR_nummod),
    Onf (relations),
    Onf (raise_gov),
    Onf (fail_label),
  )
}

strat udpos {
  Seq (
    Onf (UDPOS_init),
    Onf (minimize_conj_dep),
    Onf (chained_relations),
    Onf (reverse),
    Onf (UDPOS_after_reverse),
    Onf (relations),
    Onf (fail_label),
  )
}
